<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>friendly_ground_truth.controller.controller API documentation</title>
<meta name="description" content="File Name: controller.py â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>friendly_ground_truth.controller.controller</code></h1>
</header>
<section id="section-intro">
<p>File Name: controller.py</p>
<p>Authors: Kyle Seidenthal</p>
<p>Date: 13-05-2020</p>
<p>Description: Main controller for the application</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
File Name: controller.py

Authors: Kyle Seidenthal

Date: 13-05-2020

Description: Main controller for the application

&#34;&#34;&#34;
from friendly_ground_truth.view.main_window import MainWindow
from friendly_ground_truth.view.preview_window import PreviewWindow
from friendly_ground_truth.controller.tools import (ThresholdTool,
                                                    AddRegionTool,
                                                    RemoveRegionTool,
                                                    NoRootTool,
                                                    FloodAddTool,
                                                    FloodRemoveTool,
                                                    PreviousPatchTool,
                                                    NextPatchTool,
                                                    UndoTool,
                                                    RedoTool)

from friendly_ground_truth.controller.undo_manager import UndoManager
from friendly_ground_truth.model.model import Image

from skimage import segmentation, img_as_ubyte

from sys import platform

import os
import copy
import json

import tkinter.filedialog
import tkinter.messagebox

import numpy as np

import logging
module_logger = logging.getLogger(&#39;friendly_gt.controller.controller&#39;)


class Controller():
    &#34;&#34;&#34;
    Main controller for the application.

    Attributes:
        image_tools: A dictionary of tools keyed by their id
    &#34;&#34;&#34;
    CONTEXT_TRANSPARENCY = 100
    NUM_PATCHES = 10

    DEFAULT_PREFS = {&#39;theme&#39;: &#39;Light&#39;}

    def __init__(self, root):
        &#34;&#34;&#34;
        Create a Controller object

        Args:
            root: The tk Root

        Returns:
            A controller object

        Postconditions:
            The main application window is started
        &#34;&#34;&#34;
        # ------------------------------------
        # Private Attributes
        # -----------------------------------

        self.PREFERENCES_PATH = self.get_preferences_path()

        # The root tkinter object
        self._root = root
        # For logging
        self._logger = logging.getLogger(&#39;friendly_gt.controller.&#39;
                                         &#39;controller.Controller&#39;)
        # The last directory used to load an image
        self._last_load_dir = None
        # The last directory used to save an image
        self._last_save_dir = None

        # Image containing neighbouring patches
        self._context_img = None

        # For managing undo operations
        self._undo_manager = UndoManager()
        # A dictionary of image tools
        self._image_tools = {}
        self._init_tools()

        # Initialize the main window
        self._main_window = MainWindow(self._root, self)

        # The path to the current image
        self._image_path = None

        # The current image
        self._image = None

        # The index of the current patch in _image.patches
        self._current_patch_index = 0

        # Whether the mask has been saved
        self._mask_saved = False

        # The current tool in use
        self._current_tool = None

        # The offset of the current patch within the context image
        self._patch_offset = (0, 0)

        # Whether the mask preview has been shown or not
        self._previewed = False

        # Disable the redo button for now
        self._main_window.disable_button(self._redo_id)
        self._main_window.disable_button(self._undo_id)

    @property
    def image_tools(self):
        return self._image_tools

    # ===================================================
    # PUBLIC FUNCTIONS
    # ===================================================
    def get_preferences_path(self):
        &#34;&#34;&#34;
        Return the path to the preferences file.


        Returns:
            The path to the preferences file.
        &#34;&#34;&#34;
        if platform != &#39;win32&#39;:

            home = os.path.expanduser(&#34;~&#34;)
            data_dir = os.path.join(home, &#34;.friendly_ground_truth/&#34;)

            if not os.path.exists(data_dir):
                os.mkdir(data_dir)

            preferences_path = os.path.join(data_dir,
                                            &#34;user_preferences.json&#34;)

        else:
            preferences_path = &#34;./user_preferences.json&#34;

        return preferences_path

    def load_new_image(self):
        &#34;&#34;&#34;
        Load a new image with a file dialog.


        Returns:
            None
        &#34;&#34;&#34;

        self._context_img = None
        filetypes = [(&#34;TIF Files&#34;, &#34;*.tif&#34;), (&#34;TIFF Files&#34;, &#34;*.tiff&#34;),
                     (&#34;PNG Files&#34;, &#34;*.png&#34;), (&#34;JPEG Files&#34;, &#34;*.jpg&#34;)]

        if self._last_load_dir is None:
            initial_dir = os.path.expanduser(&#34;~&#34;)
        else:
            initial_dir = self._last_load_dir

        file_name = tkinter.filedialog.askopenfilename(filetypes=filetypes,
                                                       initialdir=initial_dir)

        if file_name is None or file_name == ():
            return

        self._last_load_dir = os.path.split(file_name)[0]

        self._image_path = file_name

        try:
            self._main_window.start_progressbar(self.NUM_PATCHES ** 2)

            del self._image
            self._image = Image(file_name, 10, self._update_progressbar)

        except FileNotFoundError:
            self._logger.exception(&#34;There was a problem loading the image.&#34;)
            return

        self._current_patch_index = 0

        self._display_current_patch(new=True)
        self._main_window.update_image_indicator(self._image_path)

    def save_mask(self):
        &#34;&#34;&#34;
        Save the finished image mask.


        Returns:
            None
        &#34;&#34;&#34;

        if self._image is None:
            return

        if not self._previewed:
            self._show_saved_preview()
            return

        self._mask_saved = True

        if self._last_save_dir is None:
            initial_dir = os.path.expanduser(&#34;~&#34;)
        else:
            initial_dir = self._last_save_dir

        dir_path = tkinter.filedialog.askdirectory(initialdir=initial_dir)

        if dir_path is None:
            return

        image_name = self._get_image_name_from_path(self._image_path)
        # labels_name = self._get_landmark_name_from_path(self._image_path)

        mask_pathname = os.path.join(dir_path, image_name)
        # label_pathname = os.path.join(dir_path, labels_name)

        try:
            self._image.export_mask(mask_pathname)
            # self._image.export_labels(label_pathname)

            tkinter.messagebox.showinfo(&#34;Image Mask Saved!&#34;,
                                        &#34;Image Mask Saved!&#34;)
            self._previewed = False

        except IOError:
            self._logger.error(&#34;Could not save file!&#34;)

    def set_preferences(self, preferences):
        &#34;&#34;&#34;
        Set the current preferences for the application.

        Args:
            preferences: A dictionary of preferences and their values.

        Returns:
            None
        &#34;&#34;&#34;
        theme = preferences[&#39;theme&#39;]

        self._main_window.set_theme(theme)

    def load_preferences(self):
        &#34;&#34;&#34;
        Load the preferences saved in the preferences file.


        Returns:
            A dictionary containing the user&#39;s preferences.
        &#34;&#34;&#34;
        if not os.path.exists(self.PREFERENCES_PATH):
            return self.DEFAULT_PREFS

        with open(self.PREFERENCES_PATH, &#39;r&#39;) as fin:
            preferences = json.load(fin)

        return preferences

    def save_preferences(self, preferences):
        &#34;&#34;&#34;
        Save the user preferences.

        Args:
            preferences: A dictionary containing the user preferences.

        Returns:
            None
        &#34;&#34;&#34;

        with open(self.PREFERENCES_PATH, &#39;w&#39;) as fout:
            json.dump(preferences, fout)

    def activate_tool(self, id):
        &#34;&#34;&#34;
        Activate the given tool id.

        Args:
            id: The id of the tool.

        Returns:
            None

        Postcondition:
            The current tool is set to the tool matching the id
            Any activation functionality of the tool is performed.
        &#34;&#34;&#34;
        if self._image is None:
            return

        tool = self.image_tools[id]
        tool.image = self._image
        tool.patch = self._image.patches[self._current_patch_index]

        old_tool = None

        if not tool.persistant:
            old_tool = self._current_tool

        self._current_tool = tool

        tool.on_activate(self._current_patch_index)

        if old_tool is not None:
            self._current_tool = old_tool
            tool = old_tool

        tool.lock_undos()
        # self._display_current_patch()
        self._main_window.update_info_panel(tool)
        self._main_window.set_canvas_cursor(tool.cursor)
        tool.unlock_undos()

        if not self._undo_manager.undo_empty:
            self._main_window.enable_button(self._undo_id)

    def adjust_tool(self, direction):
        &#34;&#34;&#34;
        Adjust the current tool.

        Args:
            direction: An integer, positive is up, negative is down.

        Returns:
            None
        &#34;&#34;&#34;
        self._current_tool.on_adjust(direction)
        # self._display_current_patch()

        if not self._undo_manager.undo_empty:
            self._main_window.enable_button(self._undo_id)

    def click_event(self, pos):
        &#34;&#34;&#34;
        A click event in the main window has occured.

        Args:
            pos: The position of the event.

        Returns:
            None
        &#34;&#34;&#34;
        # Correct for offset in context image
        pos = pos[0] - self._patch_offset[1], pos[1] - self._patch_offset[0]

        # Need to invert the position, because tkinter coords are backward from
        # skimage
        pos = round(pos[1]-1), round(pos[0]-1)

        self._logger.debug(&#34;Click Event: {}&#34;.format(pos))

        if self._current_tool is not None:
            self._current_tool.on_click(pos)

        if not self._undo_manager.undo_empty:
            self._main_window.enable_button(self._undo_id)

    def drag_event(self, pos, drag_id=None):
        &#34;&#34;&#34;
        A click event in the main window has occured/

        Args:
            pos: The position of the event.
            drag_id: Unique identifier for the drag event.

        Returns:
            None
        &#34;&#34;&#34;
        # Correct for offset in context image
        pos = pos[0] - self._patch_offset[1], pos[1] - self._patch_offset[0]

        # Need to invert the position, because tkinter coords are backward from
        # skimage
        pos = round(pos[1]-1), round(pos[0]-1)

        self._current_tool.on_drag(pos, drag_id=drag_id)

        if not self._undo_manager.undo_empty:
            self._main_window.enable_button(self._undo_id)

    # ===================================================
    # Private Functions
    # ===================================================

    def _init_tools(self):
        &#34;&#34;&#34;
        Create all the required tools.


        Returns:
            None

        Postconditions:
            self._image_tools will be created as a dictionary of id, tool pairs
        &#34;&#34;&#34;

        image_tools = {}

        thresh_tool = ThresholdTool(self._undo_manager)
        image_tools[thresh_tool.id] = thresh_tool

        add_reg_tool = AddRegionTool(self._undo_manager)
        add_reg_tool.bind_brush(self._brush_size_callback)
        image_tools[add_reg_tool.id] = add_reg_tool

        rem_reg_tool = RemoveRegionTool(self._undo_manager)
        rem_reg_tool.bind_brush(self._brush_size_callback)
        image_tools[rem_reg_tool.id] = rem_reg_tool

        flood_add_tool = FloodAddTool(self._undo_manager)
        image_tools[flood_add_tool.id] = flood_add_tool

        flood_rem_tool = FloodRemoveTool(self._undo_manager)
        image_tools[flood_rem_tool.id] = flood_rem_tool

        no_root_tool = NoRootTool(self._undo_manager,
                                  self._next_patch_callback)
        image_tools[no_root_tool.id] = no_root_tool

        prev_patch_tool = PreviousPatchTool(self._undo_manager,
                                            self._prev_patch_callback)
        image_tools[prev_patch_tool.id] = prev_patch_tool

        next_patch_tool = NextPatchTool(self._undo_manager,
                                        self._next_patch_callback)
        image_tools[next_patch_tool.id] = next_patch_tool

        undo_tool = UndoTool(self._undo_manager,
                             self._undo_callback)
        image_tools[undo_tool.id] = undo_tool
        self._undo_id = undo_tool.id

        redo_tool = RedoTool(self._undo_manager,
                             self._redo_callback)
        image_tools[redo_tool.id] = redo_tool
        self._redo_id = redo_tool.id

        for id in image_tools.keys():
            image_tools[id].bind_to(self._display_current_patch)

        self._image_tools = image_tools

    def _next_patch_callback(self, patch, index):
        &#34;&#34;&#34;
        Called when the next patch is determined.

        Args:
            patch: The next patch.
            index: The index in the patches list of the patch.

        Returns:
            None
        &#34;&#34;&#34;
        self._logger.debug(&#34;Next patch {}.&#34;.format(index))

        if patch is None or index == -1:
            self._display_current_patch()
            self.save_mask()
            return

        cur_patch = self._image.patches[self._current_patch_index]
        cur_patch.undo_history = copy.deepcopy(self._undo_manager)

        self._context_img = None
        self._current_patch_index = index

        cur_patch = self._image.patches[self._current_patch_index]

        if cur_patch.undo_history is None:
            self._undo_manager = UndoManager()
        else:
            self._undo_manager = copy.deepcopy(cur_patch.undo_history)

        for key in self._image_tools.keys():
            self._image_tools[key].patch = patch
            self._image_tools[key].undo_manager = self._undo_manager

        self._display_current_patch(new=True)

        if self._undo_manager.undo_empty:
            self._main_window.disable_button(self._undo_id)
        else:
            self._main_window.enable_button(self._undo_id)

        if self._undo_manager.redo_empty:
            self._main_window.disable_button(self._redo_id)
        else:
            self._main_window.enable_button(self._redo_id)

    def _prev_patch_callback(self, patch, index):
        &#34;&#34;&#34;
        Called when the previous patch is determined.

        Args:
            patch: The previous patch
            index: The index of that patch in the list of patches.

        Returns:
            None
        &#34;&#34;&#34;

        if patch is None or index == -1:
            return

        cur_patch = self._image.patches[self._current_patch_index]
        cur_patch.undo_history = copy.deepcopy(self._undo_manager)

        self._context_img = None
        self._current_patch_index = index

        cur_patch = self._image.patches[self._current_patch_index]

        if cur_patch.undo_history is None:
            self._undo_manager = UndoManager()
        else:
            self._undo_manager = copy.deepcopy(cur_patch.undo_history)

        for key in self._image_tools.keys():
            self._image_tools[key].patch = patch
            self._image_tools[key].undo_manager = self._undo_manager

        self._display_current_patch(new=True)

        self._main_window.disable_button(self._undo_id)
        self._main_window.disable_button(self._redo_id)

    def _undo_callback(self, patch, string):
        &#34;&#34;&#34;
        Called when undo is done.

        Args:
            patch: The patch returned from the undo stack.
            string: The string for that patch.

        Returns:
            None
        &#34;&#34;&#34;
        if patch is None:
            return

        current_patch = self._image.patches[self._current_patch_index]

        self._undo_manager.add_to_redo_stack(copy.deepcopy(current_patch),
                                             string)

        self._main_window.enable_button(self._redo_id)

        if self._undo_manager.undo_empty:
            self._main_window.disable_button(self._undo_id)

        self._image.patches[self._current_patch_index] = patch

        for key in self._image_tools.keys():
            self._image_tools[key].lock_undos()
            self._image_tools[key].patch = patch

    def _redo_callback(self, patch, string):
        &#34;&#34;&#34;
        Called when redo is done.

        Args:
            patch: The patch returned from the redo stack.
            string: The string for that patch.

        Returns:
            None
        &#34;&#34;&#34;
        if patch is None:
            return

        current_patch = self._image.patches[self._current_patch_index]

        self._undo_manager.add_to_undo_stack(copy.deepcopy(current_patch),
                                             string)

        if self._undo_manager.redo_empty:
            self._main_window.disable_button(self._redo_id)

        self._main_window.enable_button(self._undo_id)

        self._image.patches[self._current_patch_index] = patch

        for key in self._image_tools.keys():
            self._image_tools[key].lock_undos()
            self._image_tools[key].patch = patch

    def _display_current_patch(self, new=False):
        &#34;&#34;&#34;
        Display the current patch.


        Returns:
            None

        Postconditions:
            The main window&#39;s canvas will display the given image.
        &#34;&#34;&#34;
        if self._image is None:
            return

        patch = self._image.patches[self._current_patch_index]
        img = self._get_context_patches(patch)

        self._main_window.show_image(img, new=new,
                                     patch_offset=self._patch_offset)

        if self._current_tool is not None:
            self._current_tool.unlock_undos()
        if self._undo_manager.undo_empty:
            self._main_window.disable_button(self._undo_id)
        else:
            self._main_window.enable_button(self._undo_id)

    def _brush_size_callback(self, radius):
        &#34;&#34;&#34;
        Called when a brush tool is updated.

        Args:
            radius: The new brush radius.

        Returns:
            None
        &#34;&#34;&#34;
        self._main_window.set_canvas_brush_size(radius)

    def _get_context_patches(self, patch):
        &#34;&#34;&#34;
        Get the patches immediately surrounding the current patch and place
        them in a larger image.

        Args:
            patch: The current patch

        Returns:
            An image for display.
        &#34;&#34;&#34;

        # Find the neighbouring patches
        index = patch.patch_index

        if self._context_img is not None:
            patch = self._image.patches[self._current_patch_index]
            r_start = self._patch_offset[0]
            r_end = r_start + patch.overlay_image.shape[0]
            c_start = self._patch_offset[1]
            c_end = c_start + patch.overlay_image.shape[1]

            o_img = patch.overlay_image
            o_img = np.dstack((o_img, np.full(o_img.shape[0:-1],
                               255, dtype=o_img.dtype)))

            self._context_img[r_start:r_end, c_start:c_end] = o_img
            return self._context_img

        neighbouring_indices = []

        start_i = index[0] - 1
        start_j = index[1] - 1

        num_rows = 0
        num_cols = 0

        for i in range(start_i, start_i + 3):

            if i &lt; 0 or i &gt;= self._image.num_patches:
                continue
            for j in range(start_j, start_j + 3):
                if j &lt; 0 or j &gt;= self._image.num_patches:
                    continue

                neighbouring_indices.append((i, j))

                if num_rows == 0:
                    num_cols += 1
            num_rows += 1

        neighbouring_patches = []
        drawable_patch_index = None  # Index of our patch in this list

        # TODO: This could be more efficient I&#39;m sure
        for i in neighbouring_indices:
            for patch in self._image.patches:
                if patch.patch_index == i:
                    o_img = patch.overlay_image

                    if i == index:
                        o_img = np.dstack((o_img, np.full(o_img.shape[0:-1],
                                           255,
                                           dtype=o_img.dtype)))
                        drawable_patch_index = neighbouring_indices.index(i)
                    else:
                        o_img = np.dstack((o_img, np.full(o_img.shape[0:-1],
                                           self.CONTEXT_TRANSPARENCY,
                                           dtype=o_img.dtype)))

                    neighbouring_patches.append(o_img)

        # Layer them into a numpy array
        img_shape = (patch.overlay_image.shape[0] * num_rows,
                     patch.overlay_image.shape[1] * num_cols, 4)
        img = np.zeros(img_shape, dtype=np.ubyte)

        col_num = 0
        row_num = 0

        i = 0
        for patch in neighbouring_patches:
            r, c = row_num, col_num
            r = r * patch.shape[0]
            c = c * patch.shape[1]
            img[r:r+patch.shape[0],
                c:c+patch.shape[1]] += patch
            if i == drawable_patch_index:
                self._patch_offset = (r, c)

            col_num += 1

            if col_num == num_cols:
                col_num = 0
                row_num += 1

            i += 1

        self._context_img = img
        return img

    def _update_progressbar(self):
        &#34;&#34;&#34;
        Update the progressbar popup


        Returns:
            None

        Postconditions:
            The progressbar will be incremented.
        &#34;&#34;&#34;
        self._main_window.progress_popup.update()
        self._main_window.load_progress += self._main_window.progress_step
        self._main_window.load_progress_var\
            .set(self._main_window.load_progress)

        if self._main_window.load_progress &gt;= self.NUM_PATCHES ** 2:
            self._main_window.progress_popup.destroy()

    def _show_saved_preview(self):
        &#34;&#34;&#34;
        Display a preview of the saved mask overlaid with the image.


        Returns:
            None

        Postconditions:
            A window displaying the image and mask is shown.
        &#34;&#34;&#34;

        self._previewed = True

        img = self._image.image
        mask = self._image.mask

        overlay = segmentation.mark_boundaries(img, mask)

        overlay = img_as_ubyte(overlay)

        rows = np.any(mask, axis=1)
        cols = np.any(mask, axis=0)
        rmin, rmax = np.where(rows)[0][[0, -1]]
        cmin, cmax = np.where(cols)[0][[0, -1]]

        overlay = overlay[rmin:rmax, cmin:cmax]

        PreviewWindow(overlay, self, self._main_window.style)

    def _get_image_name_from_path(self, path):
        &#34;&#34;&#34;
        Get the name of the image from its original path.

        Args:
            path: The path to the original image.

        Returns:
            The name to save the image mask as.
        &#34;&#34;&#34;
        if os.path.isdir(path):
            raise ValueError(&#34;Cannot get image name from a directory.&#34;)

        basename = os.path.basename(path)

        return os.path.splitext(basename)[0] + &#39;_mask.png&#39;</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="friendly_ground_truth.controller.controller.Controller"><code class="flex name class">
<span>class <span class="ident">Controller</span></span>
<span>(</span><span>root)</span>
</code></dt>
<dd>
<div class="desc"><p>Main controller for the application.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>image_tools</code></strong></dt>
<dd>A dictionary of tools keyed by their id</dd>
</dl>
<p>Create a Controller object</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>root</code></strong></dt>
<dd>The tk Root</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>A controller object</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="postconditions">Postconditions</h2>
<p>The main application window is started</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Controller():
    &#34;&#34;&#34;
    Main controller for the application.

    Attributes:
        image_tools: A dictionary of tools keyed by their id
    &#34;&#34;&#34;
    CONTEXT_TRANSPARENCY = 100
    NUM_PATCHES = 10

    DEFAULT_PREFS = {&#39;theme&#39;: &#39;Light&#39;}

    def __init__(self, root):
        &#34;&#34;&#34;
        Create a Controller object

        Args:
            root: The tk Root

        Returns:
            A controller object

        Postconditions:
            The main application window is started
        &#34;&#34;&#34;
        # ------------------------------------
        # Private Attributes
        # -----------------------------------

        self.PREFERENCES_PATH = self.get_preferences_path()

        # The root tkinter object
        self._root = root
        # For logging
        self._logger = logging.getLogger(&#39;friendly_gt.controller.&#39;
                                         &#39;controller.Controller&#39;)
        # The last directory used to load an image
        self._last_load_dir = None
        # The last directory used to save an image
        self._last_save_dir = None

        # Image containing neighbouring patches
        self._context_img = None

        # For managing undo operations
        self._undo_manager = UndoManager()
        # A dictionary of image tools
        self._image_tools = {}
        self._init_tools()

        # Initialize the main window
        self._main_window = MainWindow(self._root, self)

        # The path to the current image
        self._image_path = None

        # The current image
        self._image = None

        # The index of the current patch in _image.patches
        self._current_patch_index = 0

        # Whether the mask has been saved
        self._mask_saved = False

        # The current tool in use
        self._current_tool = None

        # The offset of the current patch within the context image
        self._patch_offset = (0, 0)

        # Whether the mask preview has been shown or not
        self._previewed = False

        # Disable the redo button for now
        self._main_window.disable_button(self._redo_id)
        self._main_window.disable_button(self._undo_id)

    @property
    def image_tools(self):
        return self._image_tools

    # ===================================================
    # PUBLIC FUNCTIONS
    # ===================================================
    def get_preferences_path(self):
        &#34;&#34;&#34;
        Return the path to the preferences file.


        Returns:
            The path to the preferences file.
        &#34;&#34;&#34;
        if platform != &#39;win32&#39;:

            home = os.path.expanduser(&#34;~&#34;)
            data_dir = os.path.join(home, &#34;.friendly_ground_truth/&#34;)

            if not os.path.exists(data_dir):
                os.mkdir(data_dir)

            preferences_path = os.path.join(data_dir,
                                            &#34;user_preferences.json&#34;)

        else:
            preferences_path = &#34;./user_preferences.json&#34;

        return preferences_path

    def load_new_image(self):
        &#34;&#34;&#34;
        Load a new image with a file dialog.


        Returns:
            None
        &#34;&#34;&#34;

        self._context_img = None
        filetypes = [(&#34;TIF Files&#34;, &#34;*.tif&#34;), (&#34;TIFF Files&#34;, &#34;*.tiff&#34;),
                     (&#34;PNG Files&#34;, &#34;*.png&#34;), (&#34;JPEG Files&#34;, &#34;*.jpg&#34;)]

        if self._last_load_dir is None:
            initial_dir = os.path.expanduser(&#34;~&#34;)
        else:
            initial_dir = self._last_load_dir

        file_name = tkinter.filedialog.askopenfilename(filetypes=filetypes,
                                                       initialdir=initial_dir)

        if file_name is None or file_name == ():
            return

        self._last_load_dir = os.path.split(file_name)[0]

        self._image_path = file_name

        try:
            self._main_window.start_progressbar(self.NUM_PATCHES ** 2)

            del self._image
            self._image = Image(file_name, 10, self._update_progressbar)

        except FileNotFoundError:
            self._logger.exception(&#34;There was a problem loading the image.&#34;)
            return

        self._current_patch_index = 0

        self._display_current_patch(new=True)
        self._main_window.update_image_indicator(self._image_path)

    def save_mask(self):
        &#34;&#34;&#34;
        Save the finished image mask.


        Returns:
            None
        &#34;&#34;&#34;

        if self._image is None:
            return

        if not self._previewed:
            self._show_saved_preview()
            return

        self._mask_saved = True

        if self._last_save_dir is None:
            initial_dir = os.path.expanduser(&#34;~&#34;)
        else:
            initial_dir = self._last_save_dir

        dir_path = tkinter.filedialog.askdirectory(initialdir=initial_dir)

        if dir_path is None:
            return

        image_name = self._get_image_name_from_path(self._image_path)
        # labels_name = self._get_landmark_name_from_path(self._image_path)

        mask_pathname = os.path.join(dir_path, image_name)
        # label_pathname = os.path.join(dir_path, labels_name)

        try:
            self._image.export_mask(mask_pathname)
            # self._image.export_labels(label_pathname)

            tkinter.messagebox.showinfo(&#34;Image Mask Saved!&#34;,
                                        &#34;Image Mask Saved!&#34;)
            self._previewed = False

        except IOError:
            self._logger.error(&#34;Could not save file!&#34;)

    def set_preferences(self, preferences):
        &#34;&#34;&#34;
        Set the current preferences for the application.

        Args:
            preferences: A dictionary of preferences and their values.

        Returns:
            None
        &#34;&#34;&#34;
        theme = preferences[&#39;theme&#39;]

        self._main_window.set_theme(theme)

    def load_preferences(self):
        &#34;&#34;&#34;
        Load the preferences saved in the preferences file.


        Returns:
            A dictionary containing the user&#39;s preferences.
        &#34;&#34;&#34;
        if not os.path.exists(self.PREFERENCES_PATH):
            return self.DEFAULT_PREFS

        with open(self.PREFERENCES_PATH, &#39;r&#39;) as fin:
            preferences = json.load(fin)

        return preferences

    def save_preferences(self, preferences):
        &#34;&#34;&#34;
        Save the user preferences.

        Args:
            preferences: A dictionary containing the user preferences.

        Returns:
            None
        &#34;&#34;&#34;

        with open(self.PREFERENCES_PATH, &#39;w&#39;) as fout:
            json.dump(preferences, fout)

    def activate_tool(self, id):
        &#34;&#34;&#34;
        Activate the given tool id.

        Args:
            id: The id of the tool.

        Returns:
            None

        Postcondition:
            The current tool is set to the tool matching the id
            Any activation functionality of the tool is performed.
        &#34;&#34;&#34;
        if self._image is None:
            return

        tool = self.image_tools[id]
        tool.image = self._image
        tool.patch = self._image.patches[self._current_patch_index]

        old_tool = None

        if not tool.persistant:
            old_tool = self._current_tool

        self._current_tool = tool

        tool.on_activate(self._current_patch_index)

        if old_tool is not None:
            self._current_tool = old_tool
            tool = old_tool

        tool.lock_undos()
        # self._display_current_patch()
        self._main_window.update_info_panel(tool)
        self._main_window.set_canvas_cursor(tool.cursor)
        tool.unlock_undos()

        if not self._undo_manager.undo_empty:
            self._main_window.enable_button(self._undo_id)

    def adjust_tool(self, direction):
        &#34;&#34;&#34;
        Adjust the current tool.

        Args:
            direction: An integer, positive is up, negative is down.

        Returns:
            None
        &#34;&#34;&#34;
        self._current_tool.on_adjust(direction)
        # self._display_current_patch()

        if not self._undo_manager.undo_empty:
            self._main_window.enable_button(self._undo_id)

    def click_event(self, pos):
        &#34;&#34;&#34;
        A click event in the main window has occured.

        Args:
            pos: The position of the event.

        Returns:
            None
        &#34;&#34;&#34;
        # Correct for offset in context image
        pos = pos[0] - self._patch_offset[1], pos[1] - self._patch_offset[0]

        # Need to invert the position, because tkinter coords are backward from
        # skimage
        pos = round(pos[1]-1), round(pos[0]-1)

        self._logger.debug(&#34;Click Event: {}&#34;.format(pos))

        if self._current_tool is not None:
            self._current_tool.on_click(pos)

        if not self._undo_manager.undo_empty:
            self._main_window.enable_button(self._undo_id)

    def drag_event(self, pos, drag_id=None):
        &#34;&#34;&#34;
        A click event in the main window has occured/

        Args:
            pos: The position of the event.
            drag_id: Unique identifier for the drag event.

        Returns:
            None
        &#34;&#34;&#34;
        # Correct for offset in context image
        pos = pos[0] - self._patch_offset[1], pos[1] - self._patch_offset[0]

        # Need to invert the position, because tkinter coords are backward from
        # skimage
        pos = round(pos[1]-1), round(pos[0]-1)

        self._current_tool.on_drag(pos, drag_id=drag_id)

        if not self._undo_manager.undo_empty:
            self._main_window.enable_button(self._undo_id)

    # ===================================================
    # Private Functions
    # ===================================================

    def _init_tools(self):
        &#34;&#34;&#34;
        Create all the required tools.


        Returns:
            None

        Postconditions:
            self._image_tools will be created as a dictionary of id, tool pairs
        &#34;&#34;&#34;

        image_tools = {}

        thresh_tool = ThresholdTool(self._undo_manager)
        image_tools[thresh_tool.id] = thresh_tool

        add_reg_tool = AddRegionTool(self._undo_manager)
        add_reg_tool.bind_brush(self._brush_size_callback)
        image_tools[add_reg_tool.id] = add_reg_tool

        rem_reg_tool = RemoveRegionTool(self._undo_manager)
        rem_reg_tool.bind_brush(self._brush_size_callback)
        image_tools[rem_reg_tool.id] = rem_reg_tool

        flood_add_tool = FloodAddTool(self._undo_manager)
        image_tools[flood_add_tool.id] = flood_add_tool

        flood_rem_tool = FloodRemoveTool(self._undo_manager)
        image_tools[flood_rem_tool.id] = flood_rem_tool

        no_root_tool = NoRootTool(self._undo_manager,
                                  self._next_patch_callback)
        image_tools[no_root_tool.id] = no_root_tool

        prev_patch_tool = PreviousPatchTool(self._undo_manager,
                                            self._prev_patch_callback)
        image_tools[prev_patch_tool.id] = prev_patch_tool

        next_patch_tool = NextPatchTool(self._undo_manager,
                                        self._next_patch_callback)
        image_tools[next_patch_tool.id] = next_patch_tool

        undo_tool = UndoTool(self._undo_manager,
                             self._undo_callback)
        image_tools[undo_tool.id] = undo_tool
        self._undo_id = undo_tool.id

        redo_tool = RedoTool(self._undo_manager,
                             self._redo_callback)
        image_tools[redo_tool.id] = redo_tool
        self._redo_id = redo_tool.id

        for id in image_tools.keys():
            image_tools[id].bind_to(self._display_current_patch)

        self._image_tools = image_tools

    def _next_patch_callback(self, patch, index):
        &#34;&#34;&#34;
        Called when the next patch is determined.

        Args:
            patch: The next patch.
            index: The index in the patches list of the patch.

        Returns:
            None
        &#34;&#34;&#34;
        self._logger.debug(&#34;Next patch {}.&#34;.format(index))

        if patch is None or index == -1:
            self._display_current_patch()
            self.save_mask()
            return

        cur_patch = self._image.patches[self._current_patch_index]
        cur_patch.undo_history = copy.deepcopy(self._undo_manager)

        self._context_img = None
        self._current_patch_index = index

        cur_patch = self._image.patches[self._current_patch_index]

        if cur_patch.undo_history is None:
            self._undo_manager = UndoManager()
        else:
            self._undo_manager = copy.deepcopy(cur_patch.undo_history)

        for key in self._image_tools.keys():
            self._image_tools[key].patch = patch
            self._image_tools[key].undo_manager = self._undo_manager

        self._display_current_patch(new=True)

        if self._undo_manager.undo_empty:
            self._main_window.disable_button(self._undo_id)
        else:
            self._main_window.enable_button(self._undo_id)

        if self._undo_manager.redo_empty:
            self._main_window.disable_button(self._redo_id)
        else:
            self._main_window.enable_button(self._redo_id)

    def _prev_patch_callback(self, patch, index):
        &#34;&#34;&#34;
        Called when the previous patch is determined.

        Args:
            patch: The previous patch
            index: The index of that patch in the list of patches.

        Returns:
            None
        &#34;&#34;&#34;

        if patch is None or index == -1:
            return

        cur_patch = self._image.patches[self._current_patch_index]
        cur_patch.undo_history = copy.deepcopy(self._undo_manager)

        self._context_img = None
        self._current_patch_index = index

        cur_patch = self._image.patches[self._current_patch_index]

        if cur_patch.undo_history is None:
            self._undo_manager = UndoManager()
        else:
            self._undo_manager = copy.deepcopy(cur_patch.undo_history)

        for key in self._image_tools.keys():
            self._image_tools[key].patch = patch
            self._image_tools[key].undo_manager = self._undo_manager

        self._display_current_patch(new=True)

        self._main_window.disable_button(self._undo_id)
        self._main_window.disable_button(self._redo_id)

    def _undo_callback(self, patch, string):
        &#34;&#34;&#34;
        Called when undo is done.

        Args:
            patch: The patch returned from the undo stack.
            string: The string for that patch.

        Returns:
            None
        &#34;&#34;&#34;
        if patch is None:
            return

        current_patch = self._image.patches[self._current_patch_index]

        self._undo_manager.add_to_redo_stack(copy.deepcopy(current_patch),
                                             string)

        self._main_window.enable_button(self._redo_id)

        if self._undo_manager.undo_empty:
            self._main_window.disable_button(self._undo_id)

        self._image.patches[self._current_patch_index] = patch

        for key in self._image_tools.keys():
            self._image_tools[key].lock_undos()
            self._image_tools[key].patch = patch

    def _redo_callback(self, patch, string):
        &#34;&#34;&#34;
        Called when redo is done.

        Args:
            patch: The patch returned from the redo stack.
            string: The string for that patch.

        Returns:
            None
        &#34;&#34;&#34;
        if patch is None:
            return

        current_patch = self._image.patches[self._current_patch_index]

        self._undo_manager.add_to_undo_stack(copy.deepcopy(current_patch),
                                             string)

        if self._undo_manager.redo_empty:
            self._main_window.disable_button(self._redo_id)

        self._main_window.enable_button(self._undo_id)

        self._image.patches[self._current_patch_index] = patch

        for key in self._image_tools.keys():
            self._image_tools[key].lock_undos()
            self._image_tools[key].patch = patch

    def _display_current_patch(self, new=False):
        &#34;&#34;&#34;
        Display the current patch.


        Returns:
            None

        Postconditions:
            The main window&#39;s canvas will display the given image.
        &#34;&#34;&#34;
        if self._image is None:
            return

        patch = self._image.patches[self._current_patch_index]
        img = self._get_context_patches(patch)

        self._main_window.show_image(img, new=new,
                                     patch_offset=self._patch_offset)

        if self._current_tool is not None:
            self._current_tool.unlock_undos()
        if self._undo_manager.undo_empty:
            self._main_window.disable_button(self._undo_id)
        else:
            self._main_window.enable_button(self._undo_id)

    def _brush_size_callback(self, radius):
        &#34;&#34;&#34;
        Called when a brush tool is updated.

        Args:
            radius: The new brush radius.

        Returns:
            None
        &#34;&#34;&#34;
        self._main_window.set_canvas_brush_size(radius)

    def _get_context_patches(self, patch):
        &#34;&#34;&#34;
        Get the patches immediately surrounding the current patch and place
        them in a larger image.

        Args:
            patch: The current patch

        Returns:
            An image for display.
        &#34;&#34;&#34;

        # Find the neighbouring patches
        index = patch.patch_index

        if self._context_img is not None:
            patch = self._image.patches[self._current_patch_index]
            r_start = self._patch_offset[0]
            r_end = r_start + patch.overlay_image.shape[0]
            c_start = self._patch_offset[1]
            c_end = c_start + patch.overlay_image.shape[1]

            o_img = patch.overlay_image
            o_img = np.dstack((o_img, np.full(o_img.shape[0:-1],
                               255, dtype=o_img.dtype)))

            self._context_img[r_start:r_end, c_start:c_end] = o_img
            return self._context_img

        neighbouring_indices = []

        start_i = index[0] - 1
        start_j = index[1] - 1

        num_rows = 0
        num_cols = 0

        for i in range(start_i, start_i + 3):

            if i &lt; 0 or i &gt;= self._image.num_patches:
                continue
            for j in range(start_j, start_j + 3):
                if j &lt; 0 or j &gt;= self._image.num_patches:
                    continue

                neighbouring_indices.append((i, j))

                if num_rows == 0:
                    num_cols += 1
            num_rows += 1

        neighbouring_patches = []
        drawable_patch_index = None  # Index of our patch in this list

        # TODO: This could be more efficient I&#39;m sure
        for i in neighbouring_indices:
            for patch in self._image.patches:
                if patch.patch_index == i:
                    o_img = patch.overlay_image

                    if i == index:
                        o_img = np.dstack((o_img, np.full(o_img.shape[0:-1],
                                           255,
                                           dtype=o_img.dtype)))
                        drawable_patch_index = neighbouring_indices.index(i)
                    else:
                        o_img = np.dstack((o_img, np.full(o_img.shape[0:-1],
                                           self.CONTEXT_TRANSPARENCY,
                                           dtype=o_img.dtype)))

                    neighbouring_patches.append(o_img)

        # Layer them into a numpy array
        img_shape = (patch.overlay_image.shape[0] * num_rows,
                     patch.overlay_image.shape[1] * num_cols, 4)
        img = np.zeros(img_shape, dtype=np.ubyte)

        col_num = 0
        row_num = 0

        i = 0
        for patch in neighbouring_patches:
            r, c = row_num, col_num
            r = r * patch.shape[0]
            c = c * patch.shape[1]
            img[r:r+patch.shape[0],
                c:c+patch.shape[1]] += patch
            if i == drawable_patch_index:
                self._patch_offset = (r, c)

            col_num += 1

            if col_num == num_cols:
                col_num = 0
                row_num += 1

            i += 1

        self._context_img = img
        return img

    def _update_progressbar(self):
        &#34;&#34;&#34;
        Update the progressbar popup


        Returns:
            None

        Postconditions:
            The progressbar will be incremented.
        &#34;&#34;&#34;
        self._main_window.progress_popup.update()
        self._main_window.load_progress += self._main_window.progress_step
        self._main_window.load_progress_var\
            .set(self._main_window.load_progress)

        if self._main_window.load_progress &gt;= self.NUM_PATCHES ** 2:
            self._main_window.progress_popup.destroy()

    def _show_saved_preview(self):
        &#34;&#34;&#34;
        Display a preview of the saved mask overlaid with the image.


        Returns:
            None

        Postconditions:
            A window displaying the image and mask is shown.
        &#34;&#34;&#34;

        self._previewed = True

        img = self._image.image
        mask = self._image.mask

        overlay = segmentation.mark_boundaries(img, mask)

        overlay = img_as_ubyte(overlay)

        rows = np.any(mask, axis=1)
        cols = np.any(mask, axis=0)
        rmin, rmax = np.where(rows)[0][[0, -1]]
        cmin, cmax = np.where(cols)[0][[0, -1]]

        overlay = overlay[rmin:rmax, cmin:cmax]

        PreviewWindow(overlay, self, self._main_window.style)

    def _get_image_name_from_path(self, path):
        &#34;&#34;&#34;
        Get the name of the image from its original path.

        Args:
            path: The path to the original image.

        Returns:
            The name to save the image mask as.
        &#34;&#34;&#34;
        if os.path.isdir(path):
            raise ValueError(&#34;Cannot get image name from a directory.&#34;)

        basename = os.path.basename(path)

        return os.path.splitext(basename)[0] + &#39;_mask.png&#39;</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="friendly_ground_truth.controller.controller.Controller.CONTEXT_TRANSPARENCY"><code class="name">var <span class="ident">CONTEXT_TRANSPARENCY</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="friendly_ground_truth.controller.controller.Controller.DEFAULT_PREFS"><code class="name">var <span class="ident">DEFAULT_PREFS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="friendly_ground_truth.controller.controller.Controller.NUM_PATCHES"><code class="name">var <span class="ident">NUM_PATCHES</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="friendly_ground_truth.controller.controller.Controller.image_tools"><code class="name">var <span class="ident">image_tools</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def image_tools(self):
    return self._image_tools</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="friendly_ground_truth.controller.controller.Controller.activate_tool"><code class="name flex">
<span>def <span class="ident">activate_tool</span></span>(<span>self, id)</span>
</code></dt>
<dd>
<div class="desc"><p>Activate the given tool id.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>id</code></strong></dt>
<dd>The id of the tool.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="postcondition">Postcondition</h2>
<p>The current tool is set to the tool matching the id
Any activation functionality of the tool is performed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def activate_tool(self, id):
    &#34;&#34;&#34;
    Activate the given tool id.

    Args:
        id: The id of the tool.

    Returns:
        None

    Postcondition:
        The current tool is set to the tool matching the id
        Any activation functionality of the tool is performed.
    &#34;&#34;&#34;
    if self._image is None:
        return

    tool = self.image_tools[id]
    tool.image = self._image
    tool.patch = self._image.patches[self._current_patch_index]

    old_tool = None

    if not tool.persistant:
        old_tool = self._current_tool

    self._current_tool = tool

    tool.on_activate(self._current_patch_index)

    if old_tool is not None:
        self._current_tool = old_tool
        tool = old_tool

    tool.lock_undos()
    # self._display_current_patch()
    self._main_window.update_info_panel(tool)
    self._main_window.set_canvas_cursor(tool.cursor)
    tool.unlock_undos()

    if not self._undo_manager.undo_empty:
        self._main_window.enable_button(self._undo_id)</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.controller.controller.Controller.adjust_tool"><code class="name flex">
<span>def <span class="ident">adjust_tool</span></span>(<span>self, direction)</span>
</code></dt>
<dd>
<div class="desc"><p>Adjust the current tool.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>direction</code></strong></dt>
<dd>An integer, positive is up, negative is down.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def adjust_tool(self, direction):
    &#34;&#34;&#34;
    Adjust the current tool.

    Args:
        direction: An integer, positive is up, negative is down.

    Returns:
        None
    &#34;&#34;&#34;
    self._current_tool.on_adjust(direction)
    # self._display_current_patch()

    if not self._undo_manager.undo_empty:
        self._main_window.enable_button(self._undo_id)</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.controller.controller.Controller.click_event"><code class="name flex">
<span>def <span class="ident">click_event</span></span>(<span>self, pos)</span>
</code></dt>
<dd>
<div class="desc"><p>A click event in the main window has occured.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pos</code></strong></dt>
<dd>The position of the event.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def click_event(self, pos):
    &#34;&#34;&#34;
    A click event in the main window has occured.

    Args:
        pos: The position of the event.

    Returns:
        None
    &#34;&#34;&#34;
    # Correct for offset in context image
    pos = pos[0] - self._patch_offset[1], pos[1] - self._patch_offset[0]

    # Need to invert the position, because tkinter coords are backward from
    # skimage
    pos = round(pos[1]-1), round(pos[0]-1)

    self._logger.debug(&#34;Click Event: {}&#34;.format(pos))

    if self._current_tool is not None:
        self._current_tool.on_click(pos)

    if not self._undo_manager.undo_empty:
        self._main_window.enable_button(self._undo_id)</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.controller.controller.Controller.drag_event"><code class="name flex">
<span>def <span class="ident">drag_event</span></span>(<span>self, pos, drag_id=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A click event in the main window has occured/</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pos</code></strong></dt>
<dd>The position of the event.</dd>
<dt><strong><code>drag_id</code></strong></dt>
<dd>Unique identifier for the drag event.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def drag_event(self, pos, drag_id=None):
    &#34;&#34;&#34;
    A click event in the main window has occured/

    Args:
        pos: The position of the event.
        drag_id: Unique identifier for the drag event.

    Returns:
        None
    &#34;&#34;&#34;
    # Correct for offset in context image
    pos = pos[0] - self._patch_offset[1], pos[1] - self._patch_offset[0]

    # Need to invert the position, because tkinter coords are backward from
    # skimage
    pos = round(pos[1]-1), round(pos[0]-1)

    self._current_tool.on_drag(pos, drag_id=drag_id)

    if not self._undo_manager.undo_empty:
        self._main_window.enable_button(self._undo_id)</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.controller.controller.Controller.get_preferences_path"><code class="name flex">
<span>def <span class="ident">get_preferences_path</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the path to the preferences file.</p>
<h2 id="returns">Returns</h2>
<p>The path to the preferences file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_preferences_path(self):
    &#34;&#34;&#34;
    Return the path to the preferences file.


    Returns:
        The path to the preferences file.
    &#34;&#34;&#34;
    if platform != &#39;win32&#39;:

        home = os.path.expanduser(&#34;~&#34;)
        data_dir = os.path.join(home, &#34;.friendly_ground_truth/&#34;)

        if not os.path.exists(data_dir):
            os.mkdir(data_dir)

        preferences_path = os.path.join(data_dir,
                                        &#34;user_preferences.json&#34;)

    else:
        preferences_path = &#34;./user_preferences.json&#34;

    return preferences_path</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.controller.controller.Controller.load_new_image"><code class="name flex">
<span>def <span class="ident">load_new_image</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Load a new image with a file dialog.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_new_image(self):
    &#34;&#34;&#34;
    Load a new image with a file dialog.


    Returns:
        None
    &#34;&#34;&#34;

    self._context_img = None
    filetypes = [(&#34;TIF Files&#34;, &#34;*.tif&#34;), (&#34;TIFF Files&#34;, &#34;*.tiff&#34;),
                 (&#34;PNG Files&#34;, &#34;*.png&#34;), (&#34;JPEG Files&#34;, &#34;*.jpg&#34;)]

    if self._last_load_dir is None:
        initial_dir = os.path.expanduser(&#34;~&#34;)
    else:
        initial_dir = self._last_load_dir

    file_name = tkinter.filedialog.askopenfilename(filetypes=filetypes,
                                                   initialdir=initial_dir)

    if file_name is None or file_name == ():
        return

    self._last_load_dir = os.path.split(file_name)[0]

    self._image_path = file_name

    try:
        self._main_window.start_progressbar(self.NUM_PATCHES ** 2)

        del self._image
        self._image = Image(file_name, 10, self._update_progressbar)

    except FileNotFoundError:
        self._logger.exception(&#34;There was a problem loading the image.&#34;)
        return

    self._current_patch_index = 0

    self._display_current_patch(new=True)
    self._main_window.update_image_indicator(self._image_path)</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.controller.controller.Controller.load_preferences"><code class="name flex">
<span>def <span class="ident">load_preferences</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Load the preferences saved in the preferences file.</p>
<h2 id="returns">Returns</h2>
<p>A dictionary containing the user's preferences.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_preferences(self):
    &#34;&#34;&#34;
    Load the preferences saved in the preferences file.


    Returns:
        A dictionary containing the user&#39;s preferences.
    &#34;&#34;&#34;
    if not os.path.exists(self.PREFERENCES_PATH):
        return self.DEFAULT_PREFS

    with open(self.PREFERENCES_PATH, &#39;r&#39;) as fin:
        preferences = json.load(fin)

    return preferences</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.controller.controller.Controller.save_mask"><code class="name flex">
<span>def <span class="ident">save_mask</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Save the finished image mask.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_mask(self):
    &#34;&#34;&#34;
    Save the finished image mask.


    Returns:
        None
    &#34;&#34;&#34;

    if self._image is None:
        return

    if not self._previewed:
        self._show_saved_preview()
        return

    self._mask_saved = True

    if self._last_save_dir is None:
        initial_dir = os.path.expanduser(&#34;~&#34;)
    else:
        initial_dir = self._last_save_dir

    dir_path = tkinter.filedialog.askdirectory(initialdir=initial_dir)

    if dir_path is None:
        return

    image_name = self._get_image_name_from_path(self._image_path)
    # labels_name = self._get_landmark_name_from_path(self._image_path)

    mask_pathname = os.path.join(dir_path, image_name)
    # label_pathname = os.path.join(dir_path, labels_name)

    try:
        self._image.export_mask(mask_pathname)
        # self._image.export_labels(label_pathname)

        tkinter.messagebox.showinfo(&#34;Image Mask Saved!&#34;,
                                    &#34;Image Mask Saved!&#34;)
        self._previewed = False

    except IOError:
        self._logger.error(&#34;Could not save file!&#34;)</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.controller.controller.Controller.save_preferences"><code class="name flex">
<span>def <span class="ident">save_preferences</span></span>(<span>self, preferences)</span>
</code></dt>
<dd>
<div class="desc"><p>Save the user preferences.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>preferences</code></strong></dt>
<dd>A dictionary containing the user preferences.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_preferences(self, preferences):
    &#34;&#34;&#34;
    Save the user preferences.

    Args:
        preferences: A dictionary containing the user preferences.

    Returns:
        None
    &#34;&#34;&#34;

    with open(self.PREFERENCES_PATH, &#39;w&#39;) as fout:
        json.dump(preferences, fout)</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.controller.controller.Controller.set_preferences"><code class="name flex">
<span>def <span class="ident">set_preferences</span></span>(<span>self, preferences)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the current preferences for the application.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>preferences</code></strong></dt>
<dd>A dictionary of preferences and their values.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_preferences(self, preferences):
    &#34;&#34;&#34;
    Set the current preferences for the application.

    Args:
        preferences: A dictionary of preferences and their values.

    Returns:
        None
    &#34;&#34;&#34;
    theme = preferences[&#39;theme&#39;]

    self._main_window.set_theme(theme)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="friendly_ground_truth.controller" href="index.html">friendly_ground_truth.controller</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="friendly_ground_truth.controller.controller.Controller" href="#friendly_ground_truth.controller.controller.Controller">Controller</a></code></h4>
<ul class="">
<li><code><a title="friendly_ground_truth.controller.controller.Controller.CONTEXT_TRANSPARENCY" href="#friendly_ground_truth.controller.controller.Controller.CONTEXT_TRANSPARENCY">CONTEXT_TRANSPARENCY</a></code></li>
<li><code><a title="friendly_ground_truth.controller.controller.Controller.DEFAULT_PREFS" href="#friendly_ground_truth.controller.controller.Controller.DEFAULT_PREFS">DEFAULT_PREFS</a></code></li>
<li><code><a title="friendly_ground_truth.controller.controller.Controller.NUM_PATCHES" href="#friendly_ground_truth.controller.controller.Controller.NUM_PATCHES">NUM_PATCHES</a></code></li>
<li><code><a title="friendly_ground_truth.controller.controller.Controller.activate_tool" href="#friendly_ground_truth.controller.controller.Controller.activate_tool">activate_tool</a></code></li>
<li><code><a title="friendly_ground_truth.controller.controller.Controller.adjust_tool" href="#friendly_ground_truth.controller.controller.Controller.adjust_tool">adjust_tool</a></code></li>
<li><code><a title="friendly_ground_truth.controller.controller.Controller.click_event" href="#friendly_ground_truth.controller.controller.Controller.click_event">click_event</a></code></li>
<li><code><a title="friendly_ground_truth.controller.controller.Controller.drag_event" href="#friendly_ground_truth.controller.controller.Controller.drag_event">drag_event</a></code></li>
<li><code><a title="friendly_ground_truth.controller.controller.Controller.get_preferences_path" href="#friendly_ground_truth.controller.controller.Controller.get_preferences_path">get_preferences_path</a></code></li>
<li><code><a title="friendly_ground_truth.controller.controller.Controller.image_tools" href="#friendly_ground_truth.controller.controller.Controller.image_tools">image_tools</a></code></li>
<li><code><a title="friendly_ground_truth.controller.controller.Controller.load_new_image" href="#friendly_ground_truth.controller.controller.Controller.load_new_image">load_new_image</a></code></li>
<li><code><a title="friendly_ground_truth.controller.controller.Controller.load_preferences" href="#friendly_ground_truth.controller.controller.Controller.load_preferences">load_preferences</a></code></li>
<li><code><a title="friendly_ground_truth.controller.controller.Controller.save_mask" href="#friendly_ground_truth.controller.controller.Controller.save_mask">save_mask</a></code></li>
<li><code><a title="friendly_ground_truth.controller.controller.Controller.save_preferences" href="#friendly_ground_truth.controller.controller.Controller.save_preferences">save_preferences</a></code></li>
<li><code><a title="friendly_ground_truth.controller.controller.Controller.set_preferences" href="#friendly_ground_truth.controller.controller.Controller.set_preferences">set_preferences</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>