<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>friendly_ground_truth.controller.controller API documentation</title>
<meta name="description" content="File Name: controller.py â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>friendly_ground_truth.controller.controller</code></h1>
</header>
<section id="section-intro">
<p>File Name: controller.py</p>
<p>Authors: Kyle Seidenthal</p>
<p>Date: 20-02-2020</p>
<p>Description: The main controller for the application</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
File Name: controller.py

Authors: Kyle Seidenthal

Date: 20-02-2020

Description: The main controller for the application

&#34;&#34;&#34;

import tkinter.filedialog
import tkinter.messagebox
import logging
import os
import copy

# import matplotlib.pyplot as plt
# import skimage.io as io
import skimage.segmentation as segmentation
# import skimage.color as colour
import numpy as np

from skimage import img_as_ubyte
from friendly_ground_truth.view.tk_view import MainWindow
from friendly_ground_truth.model.model import Image

from enum import Enum

module_logger = logging.getLogger(&#39;friendly_gt.controller&#39;)


class Mode(Enum):
    &#34;&#34;&#34;
    Class representing the possible modes for editing

    Attributes:
        THREHSOLD
        ETC
    &#34;&#34;&#34;
    THRESHOLD = 1
    ADD_REGION = 2
    REMOVE_REGION = 3
    NO_ROOT = 4
    FLOOD_ADD = 6
    FLOOD_REMOVE = 7
    ADD_TIP = 8
    ADD_BRANCH = 9
    ADD_CROSSING = 10
    REMOVE_LANDMARK = 11


class SecondaryMode(Enum):
    &#34;&#34;&#34;
    Class representing secondary adjustment modes
    &#34;&#34;&#34;
    ZOOM = 1
    ADJUST_TOOL = 2


class Controller:
    &#34;&#34;&#34;
    The main controller object for the application

    Attributes:
        stuff
    &#34;&#34;&#34;
    ZOOM_SCALE = 1.10
    CONTEXT_TRANSPARENCY = 100

    def __init__(self, master):
        &#34;&#34;&#34;
        Initialize the controller module

        :returns: None
        &#34;&#34;&#34;
        self.logger = logging.getLogger(&#39;friendly_gt.controller.Controller&#39;)
        self.logger.debug(&#34;Creating controller instance&#34;)

        self.current_patch = 0
        self.mask_saved = False

        # Set up the current mode
        self.current_mode = Mode.THRESHOLD
        self.current_secondary_mode = SecondaryMode.ZOOM

        # Whether the preview has been shown
        self.previewed = False

        # Brush radii
        self.add_region_radius = 15
        self.remove_region_radius = 15
        self.add_tip_radius = 2.5
        self.add_branch_radius = 2.5
        self.add_cross_radius = 2.5
        self.remove_landmark_radius = 15

        # Flood Tolerances
        self.flood_add_tolerance = 0.05
        self.flood_remove_tolerance = 0.05

        # Set up the main window
        self.main_window = MainWindow(self, master)

        # Offset of the patch within the context image
        self.patch_offset = (0, 0)

        # Undo Management
        self.undo_manager = UndoManager()

        # Remember chosen directories
        self.last_load_dir = None
        self.last_save_dir = None
        self.image = None

    def load_new_image(self):
        &#34;&#34;&#34;
        Called when the user wants to load a new image to open a file
        browser dialogue and get the image path

        :returns: None
        &#34;&#34;&#34;
        self.context_img = None
        self.logger.debug(&#34;Opening load file dialog&#34;)
        filetypes = [(&#34;TIF Files&#34;, &#34;*.tif&#34;), (&#34;TIFF Files&#34;, &#34;*.tiff&#34;),
                     (&#34;PNG Files&#34;, &#34;*.png&#34;)]

        if self.last_load_dir is None:
            initial_dir = os.path.expanduser(&#39;~&#39;)
        else:
            initial_dir = self.last_load_dir

        file_name = tkinter.filedialog.askopenfilename(filetypes=filetypes,
                                                       initialdir=initial_dir)
        if file_name is None:
            return

        self.last_load_dir = os.path.split(file_name)[0]

        self.image_path = file_name
        self.logger.debug(&#34;File: {}&#34;.format(self.image_path))
        try:
            self.main_window.start_progressbar(Image.NUM_PATCHES ** 2)
            self.image = Image(file_name, self.update_progress_bar)

        except FileNotFoundError:
            self.logger.debug(&#34;There was a problem loading the image&#34;)
            return

        self.current_patch = 0
        self.display_current_patch()

    def update_progress_bar(self):
        &#34;&#34;&#34;
        Update the progress bar popup

        :returns: None
        &#34;&#34;&#34;

        self.main_window.prog_popup.update()
        self.main_window.load_progress += self.main_window.progress_step
        self.main_window.load_prog_var.set(self.main_window.load_progress)

        if self.main_window.load_progress &gt;= Image.NUM_PATCHES ** 2:
            self.main_window.prog_popup.destroy()

    def get_image_name_from_path(self, path):
        &#34;&#34;&#34;
        Get the filename from the image to use for saving the mask

        Args:
            path: The path to the original image
        Returns:
            The new filename for the mask
        &#34;&#34;&#34;

        if os.path.isdir(path):
            raise ValueError(&#34;Cannot get image name from a directory.&#34;)

        basename = os.path.basename(path)
        return os.path.splitext(basename)[0] + &#39;_mask.png&#39;

    def get_landmark_name_from_path(self, path):
        &#34;&#34;&#34;
        Get the name of the landmark matrix to use for saving

        :param path: The path to the original image
        :returns: The new filename for the mask
        &#34;&#34;&#34;

        if os.path.isdir(path):
            raise ValueError(&#34;Cannot get image name from a directory&#34;)

        basename = os.path.basename(path)
        return os.path.splitext(basename)[0] + &#39;_labels.npy&#39;

    def save_mask(self):
        &#34;&#34;&#34;
        Save the finished image mask

        :returns: None
        &#34;&#34;&#34;

        if not self.previewed:
            self.show_saved_preview()
            return

        self.mask_saved = True

        if self.last_save_dir is None:
            initial_dir = os.path.expanduser(&#39;~&#39;)
        else:
            initial_dir = self.last_save_dir

        dir_path = tkinter.filedialog.askdirectory(initialdir=initial_dir)

        self.last_save_dir = dir_path

        self.logger.debug(dir_path)

        if dir_path is None:
            return

        image_name = self.get_image_name_from_path(self.image_path)
        labels_name = self.get_landmark_name_from_path(self.image_path)

        self.mask_pathname = os.path.join(dir_path, image_name)
        self.label_pathname = os.path.join(dir_path, labels_name)

        try:
            self.logger.debug(&#34;Saving mask to {}&#34;.format(self.mask_pathname))
            self.image.export_mask(self.mask_pathname)
            # self.image.export_labels(self.label_pathname)
            tkinter.messagebox.showinfo(&#34;Image Mask Saved!&#34;, &#34;Image Mask&#34;
                                        &#34; Saved!&#34;)

        except IOError:
            self.logger.error(&#34;Could not save file!&#34;)
            # TODO: display dialog

    def display_current_patch(self):
        &#34;&#34;&#34;
        Display the current patch to be displayed

        :returns: None
        &#34;&#34;&#34;
        if self.image is None:
            return

        patch = self.image.patches[self.current_patch]
        img = self.get_context_patches(patch)

        self.main_window.update_tool = False
        self.main_window.update_thresh_slider_value(patch.thresh)
        self.main_window.update_add_brush_sizer(self.add_region_radius)
        self.main_window.update_remove_brush_sizer(self.remove_region_radius)
        self.main_window.\
            update_flood_add_slider_value(self.flood_add_tolerance)
        self.main_window.\
            update_flood_remove_slider_value(self.flood_remove_tolerance)
        self.main_window.set_brush_radius
        self.main_window.show_image(img)

    def get_context_patches(self, patch):
        &#34;&#34;&#34;
        Get the patches immediately surrounding the current patch and place
        them in a larger image

        :param patch: The current patch
        :returns: A matrix of patches for display
        &#34;&#34;&#34;

        # Find the neighbouring patches
        index = patch.patch_index

        if self.context_img is not None:
            patch = self.image.patches[self.current_patch]
            r_start = self.patch_offset[0]
            r_end = r_start + patch.overlay_image.shape[0]
            c_start = self.patch_offset[1]
            c_end = c_start + patch.overlay_image.shape[1]

            o_img = patch.overlay_image
            o_img = np.dstack((o_img, np.full(o_img.shape[0:-1],
                               255, dtype=o_img.dtype)))
            self.logger.debug(&#34;Using cached context image&#34;)

            self.context_img[r_start:r_end, c_start:c_end] = o_img
            return self.context_img

        neighbouring_indices = []

        start_i = index[0] - 1
        start_j = index[1] - 1

        num_rows = 0
        num_cols = 0

        for i in range(start_i, start_i + 3):

            if i &lt; 0 or i &gt;= self.image.NUM_PATCHES:
                self.logger.debug(&#34;Patch Out Of Bounds&#34;)
                continue
            for j in range(start_j, start_j + 3):
                if j &lt; 0 or j &gt;= self.image.NUM_PATCHES:
                    self.logger.debug(&#34;Patch Out Of Bounds&#34;)
                    continue

                neighbouring_indices.append((i, j))

                if num_rows == 0:
                    num_cols += 1
            num_rows += 1

        neighbouring_patches = []
        drawable_patch_index = None  # Index of our patch in this list

        # TODO: This could be more efficient I&#39;m sure
        for i in neighbouring_indices:
            for patch in self.image.patches:
                if patch.patch_index == i:
                    o_img = patch.overlay_image

                    if i == index:
                        o_img = np.dstack((o_img, np.full(o_img.shape[0:-1],
                                           255,
                                           dtype=o_img.dtype)))
                        drawable_patch_index = neighbouring_indices.index(i)
                    else:
                        o_img = np.dstack((o_img, np.full(o_img.shape[0:-1],
                                           self.CONTEXT_TRANSPARENCY,
                                           dtype=o_img.dtype)))

                    neighbouring_patches.append(o_img)

        # Layer them into a numpy array
        img_shape = (patch.overlay_image.shape[0] * num_rows,
                     patch.overlay_image.shape[1] * num_cols, 4)
        img = np.zeros(img_shape, dtype=np.ubyte)

        col_num = 0
        row_num = 0

        i = 0
        for patch in neighbouring_patches:
            r, c = row_num, col_num
            r = r * patch.shape[0]
            c = c * patch.shape[1]
            img[r:r+patch.shape[0],
                c:c+patch.shape[1]] += patch
            if i == drawable_patch_index:
                self.patch_offset = (r, c)

            col_num += 1

            if col_num == num_cols:
                col_num = 0
                row_num += 1

            i += 1

        self.context_img = img
        return img

    def convert_click_to_image_position(self, click_location):
        &#34;&#34;&#34;
        Convert a click location to coordinates in the image

        :param click_location: (x, y) coords of the click
        :returns: The corresponding coordinates in the image
        &#34;&#34;&#34;
        click_location = (click_location[0] - self.main_window.image_x,
                          click_location[1] - self.main_window.image_y)

        click_location = (click_location[0] / self.main_window.image_scale,
                          click_location[1] / self.main_window.image_scale)

        click_location = (click_location[0] - self.patch_offset[1],
                          click_location[1] - self.patch_offset[0])

        # Make sure we are clicking on the image
        if click_location[0] &lt; 0 or click_location[1] &lt; 0:
            return None

        return click_location

    def next_patch(self):
        &#34;&#34;&#34;
        Increment the current patch and display it

        :returns: None
        &#34;&#34;&#34;
        self.context_img = None
        self.undo_manager.clear_undos()

        if self.current_patch &lt; len(self.image.patches)-1:

            self.current_patch += 1
            while self.image.patches[self.current_patch].display is False:
                self.current_patch += 1

            self.display_current_patch()
        else:

            if self.mask_saved:
                return

            self.logger.error(&#34;No More Patches&#34;)

            dialog_message = &#34;No More Patches - Would you like to save the&#34; \
                             &#34; mask?&#34;

            dialog_title = &#34;No More Patches&#34;

            result = tkinter.messagebox.askyesno(title=dialog_title,
                                                 message=dialog_message)
            self.logger.debug(result)
            if result:
                self.show_saved_preview()

    def show_saved_preview(self):
        &#34;&#34;&#34;
        Display a preview of the saved mask

        :returns: None
        &#34;&#34;&#34;
        self.previewed = True
        img = self.image.image
        self.image.create_mask()
        mask = self.image.mask

        overlay = segmentation.mark_boundaries(img, mask)

        overlay = img_as_ubyte(overlay)

        rows = np.any(mask, axis=1)
        cols = np.any(mask, axis=0)
        rmin, rmax = np.where(rows)[0][[0, -1]]
        cmin, cmax = np.where(cols)[0][[0, -1]]

        overlay = overlay[rmin:rmax, cmin:cmax]

        self.main_window.create_annotation_preview(overlay)

    def prev_patch(self):
        &#34;&#34;&#34;
        Decrement the current patch and display it

        :returns: None
        &#34;&#34;&#34;
        self.context_img = None
        self.undo_manager.clear_undos()

        if self.current_patch &gt; 0:

            self.current_patch -= 1
            while self.image.patches[self.current_patch].display is False:
                self.current_patch -= 1

            self.display_current_patch()

        else:
            self.logger.error(&#34;No Previous patches&#34;)

    def change_mode(self, new_mode_id):
        &#34;&#34;&#34;
        Change the current editing mode

        :param new_mode_id: The ID of the mode button in the Main Window
        :returns: None
        &#34;&#34;&#34;
        if new_mode_id != self.main_window.ID_TOOL_NO_ROOT:
            self.main_window.zoom_cursor = False
            self.main_window.flood_cursor = False

        if new_mode_id == self.main_window.ID_TOOL_THRESH:
            self.current_mode = Mode.THRESHOLD
            self.main_window.set_brush_radius(0)
            patch = self.image.patches[self.current_patch]
            self.main_window.update_thresh_slider_value(patch.thresh)

        elif new_mode_id == self.main_window.ID_TOOL_ADD:
            self.current_mode = Mode.ADD_REGION
            self.main_window.set_brush_radius(self.add_region_radius)
            self.main_window.update_add_brush_sizer(self.add_region_radius)

        elif new_mode_id == self.main_window.ID_TOOL_REMOVE:
            self.current_mode = Mode.REMOVE_REGION
            self.main_window.set_brush_radius(self.remove_region_radius)
            self.main_window.\
                update_remove_brush_sizer(self.remove_region_radius)

        elif new_mode_id == self.main_window.ID_TOOL_NO_ROOT:
            self.no_root_activate()

        elif new_mode_id == self.main_window.ID_TOOL_FLOOD_ADD:
            self.current_mode = Mode.FLOOD_ADD
            self.main_window.flood_cursor = True
            self.flood_add_position = None
            # self.flood_add_tolerance = 0.05
            self.main_window.\
                update_flood_add_slider_value(self.flood_add_tolerance)

        elif new_mode_id == self.main_window.ID_TOOL_FLOOD_REMOVE:
            self.current_mode = Mode.FLOOD_REMOVE
            self.main_window.flood_cursor = True
            self.flood_remove_position = None
            # self.flood_remove_tolerance = 0.05
            self.main_window.\
                update_flood_remove_slider_value(self.flood_remove_tolerance)

        elif new_mode_id == self.main_window.ID_TOOL_ADD_TIP:
            self.current_mode = Mode.ADD_TIP
            self.main_window.flood_cursor = True

        elif new_mode_id == self.main_window.ID_TOOL_ADD_BRANCH:
            self.current_mode = Mode.ADD_BRANCH
            self.main_window.flood_cursor = True

        elif new_mode_id == self.main_window.ID_TOOL_ADD_CROSS:
            self.current_mode = Mode.ADD_CROSSING
            self.main_window.flood_cursor = True

        elif new_mode_id == self.main_window.ID_TOOL_REMOVE_LANDMARK:
            self.current_mode = Mode.REMOVE_LANDMARK
            self.main_window.set_brush_radius(self.remove_landmark_radius)

        else:
            self.logger.error(&#34;Invalid mode change&#34;)

            return False

    def change_secondary_mode(self, new_mode_id):
        &#34;&#34;&#34;
        Change the secondary mode (for mouse wheel tool adjustments)

        :param new_mode_id: The id of the new mode
        :returns: None
        &#34;&#34;&#34;

        if new_mode_id == self.main_window.ID_TOOL_ZOOM:
            self.current_secondary_mode = SecondaryMode.ZOOM

        elif new_mode_id == self.main_window.ID_ADJUST_TOOL:
            self.current_secondary_mode = SecondaryMode.ADJUST_TOOL

    def no_root_activate(self):
        &#34;&#34;&#34;
        Set the mask for the patch to zero, there is no root here

        :returns: None
        &#34;&#34;&#34;
        patch = self.image.patches[self.current_patch]

        self.undo_manager.add_to_undo_stack(copy.deepcopy(patch), &#39;no_root&#39;)

        patch.clear_mask()
        patch.overlay_mask()

        self.display_current_patch()

    def handle_mouse_wheel(self, wheel_rotation, x, y):
        &#34;&#34;&#34;
        Handle wheel rotation coming from the mouse

        :param wheel_rotation: The wheel rotation
        :param x: The x-position of the mouse event
        :param y: The y-position of the mouse event
        :returns: True on success, False otherwise
        &#34;&#34;&#34;

        if self.current_secondary_mode == SecondaryMode.ADJUST_TOOL:
            if self.current_mode == Mode.THRESHOLD:

                self.adjust_threshold(wheel_rotation)

            elif self.current_mode == Mode.ADD_REGION:
                self.adjust_add_region_brush(wheel_rotation)

            elif self.current_mode == Mode.REMOVE_REGION:
                self.adjust_remove_region_brush(wheel_rotation)

            elif self.current_mode == Mode.REMOVE_LANDMARK:
                self.adjust_remove_landmark_brush(wheel_rotation)

            elif self.current_mode == Mode.FLOOD_ADD:
                self.handle_flood_add_tolerance(wheel_rotation)

            elif self.current_mode == Mode.FLOOD_REMOVE:
                self.handle_flood_remove_tolerance(wheel_rotation)
            else:
                return False

        elif self.current_secondary_mode == SecondaryMode.ZOOM:
            self.handle_zoom(wheel_rotation, x, y)

        else:
            self.logger.error(&#34;Invalid mouse wheel rotation&#34;)
            return False

        return True

    def handle_flood_add_tolerance(self, wheel_rotation):
        &#34;&#34;&#34;
        Adjust the current tolerance of the flood_add tool

        :param wheel_rotation: The rotation of the mouse wheel
        :returns: None
        &#34;&#34;&#34;

        if self.flood_add_position is None:
            return

        if wheel_rotation &gt; 0:
            self.flood_add_tolerance += 0.01
        elif wheel_rotation &lt; 0:
            self.flood_add_tolerance -= 0.01

        patch = self.image.patches[self.current_patch]

        patch.flood_add_region(self.flood_add_position,
                               self.flood_add_tolerance)

        patch.overlay_mask()
        self.display_current_patch()

    def set_flood_add_tolerance(self, value):
        &#34;&#34;&#34;
        Set the current flood add tolerance

        :param value: The value to set it to
        :returns: None
        &#34;&#34;&#34;

        if self.flood_add_position is None:
            return

        self.flood_add_tolerance = value

        patch = self.image.patches[self.current_patch]

        patch.flood_add_region(self.flood_add_position,
                               self.flood_add_tolerance)

        patch.overlay_mask()
        self.display_current_patch()

    def handle_flood_remove_tolerance(self, wheel_rotation):
        &#34;&#34;&#34;
        Adjust the current tolerance of the flood_remove tool

        :param wheel_rotation: The rotation of the mouse wheel
        :returns: None
        &#34;&#34;&#34;

        if self.flood_remove_position is None:
            return

        if wheel_rotation &gt; 0:
            self.flood_remove_tolerance += 0.01
        elif wheel_rotation &lt; 0:
            self.flood_remove_tolerance -= 0.01

        patch = self.image.patches[self.current_patch]

        patch.flood_remove_region(self.flood_remove_position,
                                  self.flood_remove_tolerance)

        patch.overlay_mask()
        self.display_current_patch()

    def set_flood_remove_tolerance(self, value):
        &#34;&#34;&#34;
        Set the current flood remove tolerance

        :param value: The value to set it to
        :returns: None
        &#34;&#34;&#34;

        if self.flood_remove_position is None:
            return

        self.flood_remove_tolerance = value

        patch = self.image.patches[self.current_patch]

        patch.flood_remove_region(self.flood_remove_position,
                                  self.flood_remove_tolerance)

        patch.overlay_mask()
        self.display_current_patch()

    def handle_zoom(self, wheel_rotation, x, y):
        &#34;&#34;&#34;
        Handle zooming with the mouse wheel

        :param wheel_rotation: The roation of the mouse wheel
        :param x: The x-cooridinate
        :param y: The y-coordinate
        :returns: True on success, False otherwise
        &#34;&#34;&#34;

        old_scale = self.main_window.image_scale

        img_point = (x - self.main_window.image_x,
                     y - self.main_window.image_y)

        img_point = (img_point[0] / self.main_window.image_scale,
                     img_point[1] / self.main_window.image_scale)

        if wheel_rotation &gt; 0 and old_scale &lt; self.main_window.MAX_SCALE:
            self.main_window.image_scale *= self.ZOOM_SCALE
            new_img_point = (img_point[0] * self.ZOOM_SCALE, img_point[1] *
                             self.ZOOM_SCALE)

            translation = (new_img_point[0] - img_point[0],
                           new_img_point[1] - img_point[1])

            self.main_window.image_x -= translation[0]
            self.main_window.image_y -= translation[1]

        elif wheel_rotation &lt; 0 and old_scale &gt; self.main_window.MIN_SCALE:
            self.main_window.image_scale /= self.ZOOM_SCALE
            new_img_point = (img_point[0] / self.ZOOM_SCALE, img_point[1] /
                             self.ZOOM_SCALE)

            translation = (new_img_point[0] - img_point[0],
                           new_img_point[1] - img_point[1])

            self.main_window.image_x -= translation[0]
            self.main_window.image_y -= translation[1]

        else:
            return False

        self.logger.debug(&#34;Image Scale: {}&#34;.
                          format(self.main_window.image_scale))
        self.display_current_patch()
        return True

    def handle_left_click(self, click_location):
        &#34;&#34;&#34;
        Handle a left mouse click at the given location

        :param click_location: The location (x, y) of the click
        :returns: True on success, False otherwise
        &#34;&#34;&#34;

        click_location = self.convert_click_to_image_position(click_location)

        if click_location is None:
            return False

        if self.current_mode == Mode.ADD_REGION:
            self.logger.debug(&#34;Add region click {}&#34;.format(click_location))

            draw_radius = self.add_region_radius / self.main_window.image_scale

            patch = self.image.patches[self.current_patch]

            self.undo_manager.add_to_undo_stack(copy.deepcopy(patch),
                                                &#39;add_region&#39;)

            patch.add_region(click_location, draw_radius)

            self.display_current_patch()

        elif self.current_mode == Mode.REMOVE_REGION:
            self.logger.debug(&#34;Remove region click&#34;)

            draw_radius = (self.remove_region_radius /
                           self.main_window.image_scale)

            patch = self.image.patches[self.current_patch]

            self.undo_manager.add_to_undo_stack(copy.deepcopy(patch),
                                                &#39;remove_region&#39;)

            patch.remove_region(click_location, draw_radius)
            self.display_current_patch()

        elif self.current_mode == Mode.ADD_TIP:

            patch = self.image.patches[self.current_patch]
            patch.add_landmark(click_location, self.add_tip_radius,
                               self.image.TIP_LABEL)
            self.display_current_patch()

        elif self.current_mode == Mode.ADD_CROSSING:
            patch = self.image.patches[self.current_patch]
            patch.add_landmark(click_location, self.add_cross_radius,
                               self.image.CROSS_LABEL)
            self.display_current_patch()

        elif self.current_mode == Mode.ADD_BRANCH:
            patch = self.image.patches[self.current_patch]
            patch.add_landmark(click_location, self.add_branch_radius,
                               self.image.BRANCH_LABEL)
            self.display_current_patch()

        elif self.current_mode == Mode.REMOVE_LANDMARK:
            draw_radius = (self.remove_landmark_radius /
                           self.main_window.image_scale)

            patch = self.image.patches[self.current_patch]
            patch.remove_landmark(click_location, draw_radius)
            self.display_current_patch()

        elif self.current_mode == Mode.FLOOD_ADD:

            patch = self.image.patches[self.current_patch]

            self.undo_manager.add_to_undo_stack(copy.deepcopy(patch),
                                                &#39;flood_add&#39;)

            patch.flood_add_region(click_location, self.flood_add_tolerance)

            self.flood_add_position = click_location

            self.display_current_patch()

        elif self.current_mode == Mode.FLOOD_REMOVE:
            patch = self.image.patches[self.current_patch]

            self.undo_manager.add_to_undo_stack(copy.deepcopy(patch),
                                                &#39;flood_remove&#39;)

            patch.flood_remove_region(click_location,
                                      self.flood_remove_tolerance)

            self.flood_remove_position = click_location

            self.display_current_patch()

        else:
            return False

        return True

    def handle_right_click(self):
        &#34;&#34;&#34;
        Called when the right mouse button is clickd

        :returns: None
        &#34;&#34;&#34;
        self.logger.debug(&#34;Right click&#34;)

    def handle_left_release(self):
        &#34;&#34;&#34;
        Handle the release of the left mouse button

        :returns: True on success, False otherwise
        &#34;&#34;&#34;

        if self.current_mode == Mode.ADD_REGION:
            self.logger.debug(&#34;Add region release&#34;)
            return True

        elif self.current_mode == Mode.REMOVE_REGION:
            self.logger.debug(&#34;Remove region release&#34;)
            return True
        else:
            return False

    def handle_motion(self, position):
        &#34;&#34;&#34;
        Handle motion events of the mouse at the given position

        :param position: The position (x, y) of the mouse during the event
        :returns: True on success, False otherwise
        &#34;&#34;&#34;
        position = self.convert_click_to_image_position(position)

        if position is None:
            return False

        if self.current_mode == Mode.ADD_REGION:
            self.logger.debug(&#34;Adding region&#34;)

            draw_radius = self.add_region_radius / self.main_window.image_scale

            patch = self.image.patches[self.current_patch]

            self.undo_manager.add_to_undo_stack(copy.deepcopy(patch),
                                                &#39;add_region_adjust&#39;)

            patch.add_region(position, draw_radius)

            self.display_current_patch()

        elif self.current_mode == Mode.REMOVE_REGION:
            self.logger.debug(&#34;Removing Region&#34;)

            draw_radius = (self.remove_region_radius /
                           self.main_window.image_scale)

            patch = self.image.patches[self.current_patch]

            self.undo_manager.add_to_undo_stack(copy.deepcopy(patch),
                                                &#39;remove_region_adjust&#39;)

            patch.remove_region(position, draw_radius)
            self.display_current_patch()

        elif self.current_mode == Mode.REMOVE_LANDMARK:
            draw_radius = (self.remove_landmark_radius /
                           self.main_window.image_scale)

            patch = self.image.patches[self.current_patch]
            patch.remove_landmark(position, draw_radius)
            self.display_current_patch()

        else:
            return False

        return True

    def handle_mouse_wheel_motion(self, position):
        &#34;&#34;&#34;
        Handle when the mouse wheel is clicked and the mouse is dragged

        :param position: The position of the mouse
        :returns: None
        &#34;&#34;&#34;

        if self.current_secondary_mode == SecondaryMode.ZOOM:
            self.main_window.image_x += (position[0] -
                                         self.main_window.previous_position[0])

            self.main_window.image_y += (position[1] -
                                         self.main_window.previous_position[1])

            self.display_current_patch()

    def adjust_threshold(self, wheel_rotation):
        &#34;&#34;&#34;
        Adjust the current threshold of the patch mask

        :param wheel_rotation: The rotation of the mouse wheel
        :returns: None
        &#34;&#34;&#34;

        patch = self.image.patches[self.current_patch]

        self.undo_manager.add_to_undo_stack(copy.deepcopy(patch),
                                            &#39;threshold_adjust&#39;)

        # Adjust the threshold.  Note that it is inverted, because it feels
        # more natural to scroll down to &#39;reduce&#39; the region, rather than
        # reducing the threshold
        if wheel_rotation &gt; 0 and patch.thresh &gt; 0:
            patch.thresh -= 0.01

        elif wheel_rotation &lt; 0 and patch.thresh &lt; 1:

            patch.thresh += 0.01

        self.main_window.update_thresh_slider_value(patch.thresh)
        self.main_window.update_add_brush_sizer(self.add_region_radius)
        patch.apply_threshold(patch.thresh)
        patch.overlay_mask()

        self.logger.debug(&#34;Threshold value: {}&#34;.format(patch.thresh))
        self.display_current_patch()

    def set_threshold(self, value):
        &#34;&#34;&#34;
        Set the value of the threshold

        :param value: Value for the threshold
        :returns: Nonw
        &#34;&#34;&#34;

        patch = self.image.patches[self.current_patch]

        self.undo_manager.add_to_undo_stack(copy.deepcopy(patch),
                                            &#39;threshold_adjust&#39;)

        patch.thresh = value
        patch.apply_threshold(patch.thresh)
        patch.overlay_mask()

        self.display_current_patch()

    def adjust_add_region_brush(self, wheel_rotation):
        &#34;&#34;&#34;
        Adjust the size of the region brush

        :param wheel_rotation: The rotation of the mouse wheel
        :returns: None
        &#34;&#34;&#34;

        self.logger.debug(&#34;Adjusting add region brush&#34;)
        if wheel_rotation &gt; 0:
            self.add_region_radius += 1
        else:
            self.add_region_radius -= 1

        self.main_window.update_add_brush_sizer(self.add_region_radius)
        self.main_window.set_brush_radius(self.add_region_radius)
        self.main_window.draw_brush()

    def set_add_region_brush(self, value):
        &#34;&#34;&#34;
        Set the value of the add region brush size

        :param value: The size
        :returns: None
        &#34;&#34;&#34;

        self.add_region_radius = value

        self.main_window.set_brush_radius(self.add_region_radius)
        self.main_window.draw_brush()

    def adjust_remove_landmark_brush(self, wheel_rotation):
        &#34;&#34;&#34;
        Adjust the size of the remove landmark brush

        :param wheel_rotation: The rotation of the mouse wheel
        :returns: None
        &#34;&#34;&#34;

        if wheel_rotation &gt; 0:
            self.remove_landmark_radius += 1
        else:
            self.remove_landmark_radius -= 1

        self.main_window.set_brush_radius(self.remove_landmark_radius)
        self.main_window.draw_brush()

    def adjust_remove_region_brush(self, wheel_rotation):
        &#34;&#34;&#34;
        Adjust the size of the remove region brush

        :param wheel_rotation: the rotation of the mouse wheel
        :returns: None
        &#34;&#34;&#34;

        self.logger.debug(&#34;Adjusting the remove region brush&#34;)
        if wheel_rotation &gt; 0:
            self.remove_region_radius += 1
        else:
            self.remove_region_radius -= 1

        self.main_window.update_remove_brush_sizer(self.remove_region_radius)
        self.main_window.set_brush_radius(self.remove_region_radius)
        self.main_window.draw_brush()

    def set_remove_region_brush(self, value):
        &#34;&#34;&#34;
        Set the value of the remove region brush size

        :param value: The value
        :returns: None
        &#34;&#34;&#34;
        self.remove_region_radius = value

        self.main_window.set_brush_radius(self.remove_region_radius)
        self.main_window.draw_brush()

    def undo(self):

        patch = self.image.patches[self.current_patch]

        redo_patch, operation = self.undo_manager.undo()

        if redo_patch is None:
            return

        self.undo_manager.add_to_redo_stack(patch, operation)
        self.main_window.toolbar_buttons[self.main_window.ID_TOOL_REDO]\
            .config(state=&#34;normal&#34;)

        self.image.patches[self.current_patch] = redo_patch

        self.display_current_patch()

    def redo(self):

        patch = self.image.patches[self.current_patch]

        undo_patch, operation = self.undo_manager.redo()

        if undo_patch is None:
            return

        self.undo_manager.add_to_undo_stack(patch, operation)
        if len(self.undo_manager.redo_stack) == 0:
            self.main_window.toolbar_buttons[self.main_window.ID_TOOL_REDO]\
                .config(state=&#34;disabled&#34;)

        self.image.patches[self.current_patch] = undo_patch

        self.display_current_patch()


class UndoManager():
    &#34;&#34;&#34;
    Manages Undo Stuff
    &#34;&#34;&#34;

    MAX_SIZE = 20

    def __init__(self):
        &#34;&#34;&#34;
        Initialize the Undo Manager

        :returns: None
        &#34;&#34;&#34;

        self.undo_stack = []
        self.redo_stack = []

    def add_to_undo_stack(self, patch, operation):
        &#34;&#34;&#34;
        Add the given operation to the undo stack

        :returns: None
        &#34;&#34;&#34;

        if &#34;threshold_adjust&#34; == operation and len(self.undo_stack) &gt; 0:
            if self.undo_stack[-1][1] == operation:
                return
        elif &#34;adjust&#34; in operation and len(self.undo_stack) &gt; 0:
            if self.undo_stack[-1][1] == operation:
                self.undo_stack.pop()

        self.undo_stack.append((patch, operation))

        if len(self.undo_stack) &gt; self.MAX_SIZE:
            self.undo_stack.pop(0)

    def undo(self):
        &#34;&#34;&#34;
        Undo the last operation added to the stack

        :returns: The function and its parameters
        &#34;&#34;&#34;
        try:
            patch, operation = self.undo_stack.pop()
            return patch, operation

        except IndexError:
            return None, None

    def add_to_redo_stack(self, patch, operation):
        &#34;&#34;&#34;
        Add the given operation to the redo stack

        :returns: None
        &#34;&#34;&#34;

        self.redo_stack.append((patch, operation))

        if len(self.redo_stack) &gt; self.MAX_SIZE:
            self.redo_stack.pop(0)

    def redo(self):
        &#34;&#34;&#34;
        Redo the last undone operation

        :returns: The function and its parameters
        &#34;&#34;&#34;

        try:
            patch, operation = self.redo_stack.pop()
            return patch, operation
        except IndexError:
            return None, None

    def clear_undos(self):

        self.undo_stack = []
        self.redo_stack = []</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="friendly_ground_truth.controller.controller.Controller"><code class="flex name class">
<span>class <span class="ident">Controller</span></span>
<span>(</span><span>master)</span>
</code></dt>
<dd>
<div class="desc"><p>The main controller object for the application</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>stuff</code></strong></dt>
<dd>&nbsp;</dd>
</dl>
<p>Initialize the controller module</p>
<p>:returns: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Controller:
    &#34;&#34;&#34;
    The main controller object for the application

    Attributes:
        stuff
    &#34;&#34;&#34;
    ZOOM_SCALE = 1.10
    CONTEXT_TRANSPARENCY = 100

    def __init__(self, master):
        &#34;&#34;&#34;
        Initialize the controller module

        :returns: None
        &#34;&#34;&#34;
        self.logger = logging.getLogger(&#39;friendly_gt.controller.Controller&#39;)
        self.logger.debug(&#34;Creating controller instance&#34;)

        self.current_patch = 0
        self.mask_saved = False

        # Set up the current mode
        self.current_mode = Mode.THRESHOLD
        self.current_secondary_mode = SecondaryMode.ZOOM

        # Whether the preview has been shown
        self.previewed = False

        # Brush radii
        self.add_region_radius = 15
        self.remove_region_radius = 15
        self.add_tip_radius = 2.5
        self.add_branch_radius = 2.5
        self.add_cross_radius = 2.5
        self.remove_landmark_radius = 15

        # Flood Tolerances
        self.flood_add_tolerance = 0.05
        self.flood_remove_tolerance = 0.05

        # Set up the main window
        self.main_window = MainWindow(self, master)

        # Offset of the patch within the context image
        self.patch_offset = (0, 0)

        # Undo Management
        self.undo_manager = UndoManager()

        # Remember chosen directories
        self.last_load_dir = None
        self.last_save_dir = None
        self.image = None

    def load_new_image(self):
        &#34;&#34;&#34;
        Called when the user wants to load a new image to open a file
        browser dialogue and get the image path

        :returns: None
        &#34;&#34;&#34;
        self.context_img = None
        self.logger.debug(&#34;Opening load file dialog&#34;)
        filetypes = [(&#34;TIF Files&#34;, &#34;*.tif&#34;), (&#34;TIFF Files&#34;, &#34;*.tiff&#34;),
                     (&#34;PNG Files&#34;, &#34;*.png&#34;)]

        if self.last_load_dir is None:
            initial_dir = os.path.expanduser(&#39;~&#39;)
        else:
            initial_dir = self.last_load_dir

        file_name = tkinter.filedialog.askopenfilename(filetypes=filetypes,
                                                       initialdir=initial_dir)
        if file_name is None:
            return

        self.last_load_dir = os.path.split(file_name)[0]

        self.image_path = file_name
        self.logger.debug(&#34;File: {}&#34;.format(self.image_path))
        try:
            self.main_window.start_progressbar(Image.NUM_PATCHES ** 2)
            self.image = Image(file_name, self.update_progress_bar)

        except FileNotFoundError:
            self.logger.debug(&#34;There was a problem loading the image&#34;)
            return

        self.current_patch = 0
        self.display_current_patch()

    def update_progress_bar(self):
        &#34;&#34;&#34;
        Update the progress bar popup

        :returns: None
        &#34;&#34;&#34;

        self.main_window.prog_popup.update()
        self.main_window.load_progress += self.main_window.progress_step
        self.main_window.load_prog_var.set(self.main_window.load_progress)

        if self.main_window.load_progress &gt;= Image.NUM_PATCHES ** 2:
            self.main_window.prog_popup.destroy()

    def get_image_name_from_path(self, path):
        &#34;&#34;&#34;
        Get the filename from the image to use for saving the mask

        Args:
            path: The path to the original image
        Returns:
            The new filename for the mask
        &#34;&#34;&#34;

        if os.path.isdir(path):
            raise ValueError(&#34;Cannot get image name from a directory.&#34;)

        basename = os.path.basename(path)
        return os.path.splitext(basename)[0] + &#39;_mask.png&#39;

    def get_landmark_name_from_path(self, path):
        &#34;&#34;&#34;
        Get the name of the landmark matrix to use for saving

        :param path: The path to the original image
        :returns: The new filename for the mask
        &#34;&#34;&#34;

        if os.path.isdir(path):
            raise ValueError(&#34;Cannot get image name from a directory&#34;)

        basename = os.path.basename(path)
        return os.path.splitext(basename)[0] + &#39;_labels.npy&#39;

    def save_mask(self):
        &#34;&#34;&#34;
        Save the finished image mask

        :returns: None
        &#34;&#34;&#34;

        if not self.previewed:
            self.show_saved_preview()
            return

        self.mask_saved = True

        if self.last_save_dir is None:
            initial_dir = os.path.expanduser(&#39;~&#39;)
        else:
            initial_dir = self.last_save_dir

        dir_path = tkinter.filedialog.askdirectory(initialdir=initial_dir)

        self.last_save_dir = dir_path

        self.logger.debug(dir_path)

        if dir_path is None:
            return

        image_name = self.get_image_name_from_path(self.image_path)
        labels_name = self.get_landmark_name_from_path(self.image_path)

        self.mask_pathname = os.path.join(dir_path, image_name)
        self.label_pathname = os.path.join(dir_path, labels_name)

        try:
            self.logger.debug(&#34;Saving mask to {}&#34;.format(self.mask_pathname))
            self.image.export_mask(self.mask_pathname)
            # self.image.export_labels(self.label_pathname)
            tkinter.messagebox.showinfo(&#34;Image Mask Saved!&#34;, &#34;Image Mask&#34;
                                        &#34; Saved!&#34;)

        except IOError:
            self.logger.error(&#34;Could not save file!&#34;)
            # TODO: display dialog

    def display_current_patch(self):
        &#34;&#34;&#34;
        Display the current patch to be displayed

        :returns: None
        &#34;&#34;&#34;
        if self.image is None:
            return

        patch = self.image.patches[self.current_patch]
        img = self.get_context_patches(patch)

        self.main_window.update_tool = False
        self.main_window.update_thresh_slider_value(patch.thresh)
        self.main_window.update_add_brush_sizer(self.add_region_radius)
        self.main_window.update_remove_brush_sizer(self.remove_region_radius)
        self.main_window.\
            update_flood_add_slider_value(self.flood_add_tolerance)
        self.main_window.\
            update_flood_remove_slider_value(self.flood_remove_tolerance)
        self.main_window.set_brush_radius
        self.main_window.show_image(img)

    def get_context_patches(self, patch):
        &#34;&#34;&#34;
        Get the patches immediately surrounding the current patch and place
        them in a larger image

        :param patch: The current patch
        :returns: A matrix of patches for display
        &#34;&#34;&#34;

        # Find the neighbouring patches
        index = patch.patch_index

        if self.context_img is not None:
            patch = self.image.patches[self.current_patch]
            r_start = self.patch_offset[0]
            r_end = r_start + patch.overlay_image.shape[0]
            c_start = self.patch_offset[1]
            c_end = c_start + patch.overlay_image.shape[1]

            o_img = patch.overlay_image
            o_img = np.dstack((o_img, np.full(o_img.shape[0:-1],
                               255, dtype=o_img.dtype)))
            self.logger.debug(&#34;Using cached context image&#34;)

            self.context_img[r_start:r_end, c_start:c_end] = o_img
            return self.context_img

        neighbouring_indices = []

        start_i = index[0] - 1
        start_j = index[1] - 1

        num_rows = 0
        num_cols = 0

        for i in range(start_i, start_i + 3):

            if i &lt; 0 or i &gt;= self.image.NUM_PATCHES:
                self.logger.debug(&#34;Patch Out Of Bounds&#34;)
                continue
            for j in range(start_j, start_j + 3):
                if j &lt; 0 or j &gt;= self.image.NUM_PATCHES:
                    self.logger.debug(&#34;Patch Out Of Bounds&#34;)
                    continue

                neighbouring_indices.append((i, j))

                if num_rows == 0:
                    num_cols += 1
            num_rows += 1

        neighbouring_patches = []
        drawable_patch_index = None  # Index of our patch in this list

        # TODO: This could be more efficient I&#39;m sure
        for i in neighbouring_indices:
            for patch in self.image.patches:
                if patch.patch_index == i:
                    o_img = patch.overlay_image

                    if i == index:
                        o_img = np.dstack((o_img, np.full(o_img.shape[0:-1],
                                           255,
                                           dtype=o_img.dtype)))
                        drawable_patch_index = neighbouring_indices.index(i)
                    else:
                        o_img = np.dstack((o_img, np.full(o_img.shape[0:-1],
                                           self.CONTEXT_TRANSPARENCY,
                                           dtype=o_img.dtype)))

                    neighbouring_patches.append(o_img)

        # Layer them into a numpy array
        img_shape = (patch.overlay_image.shape[0] * num_rows,
                     patch.overlay_image.shape[1] * num_cols, 4)
        img = np.zeros(img_shape, dtype=np.ubyte)

        col_num = 0
        row_num = 0

        i = 0
        for patch in neighbouring_patches:
            r, c = row_num, col_num
            r = r * patch.shape[0]
            c = c * patch.shape[1]
            img[r:r+patch.shape[0],
                c:c+patch.shape[1]] += patch
            if i == drawable_patch_index:
                self.patch_offset = (r, c)

            col_num += 1

            if col_num == num_cols:
                col_num = 0
                row_num += 1

            i += 1

        self.context_img = img
        return img

    def convert_click_to_image_position(self, click_location):
        &#34;&#34;&#34;
        Convert a click location to coordinates in the image

        :param click_location: (x, y) coords of the click
        :returns: The corresponding coordinates in the image
        &#34;&#34;&#34;
        click_location = (click_location[0] - self.main_window.image_x,
                          click_location[1] - self.main_window.image_y)

        click_location = (click_location[0] / self.main_window.image_scale,
                          click_location[1] / self.main_window.image_scale)

        click_location = (click_location[0] - self.patch_offset[1],
                          click_location[1] - self.patch_offset[0])

        # Make sure we are clicking on the image
        if click_location[0] &lt; 0 or click_location[1] &lt; 0:
            return None

        return click_location

    def next_patch(self):
        &#34;&#34;&#34;
        Increment the current patch and display it

        :returns: None
        &#34;&#34;&#34;
        self.context_img = None
        self.undo_manager.clear_undos()

        if self.current_patch &lt; len(self.image.patches)-1:

            self.current_patch += 1
            while self.image.patches[self.current_patch].display is False:
                self.current_patch += 1

            self.display_current_patch()
        else:

            if self.mask_saved:
                return

            self.logger.error(&#34;No More Patches&#34;)

            dialog_message = &#34;No More Patches - Would you like to save the&#34; \
                             &#34; mask?&#34;

            dialog_title = &#34;No More Patches&#34;

            result = tkinter.messagebox.askyesno(title=dialog_title,
                                                 message=dialog_message)
            self.logger.debug(result)
            if result:
                self.show_saved_preview()

    def show_saved_preview(self):
        &#34;&#34;&#34;
        Display a preview of the saved mask

        :returns: None
        &#34;&#34;&#34;
        self.previewed = True
        img = self.image.image
        self.image.create_mask()
        mask = self.image.mask

        overlay = segmentation.mark_boundaries(img, mask)

        overlay = img_as_ubyte(overlay)

        rows = np.any(mask, axis=1)
        cols = np.any(mask, axis=0)
        rmin, rmax = np.where(rows)[0][[0, -1]]
        cmin, cmax = np.where(cols)[0][[0, -1]]

        overlay = overlay[rmin:rmax, cmin:cmax]

        self.main_window.create_annotation_preview(overlay)

    def prev_patch(self):
        &#34;&#34;&#34;
        Decrement the current patch and display it

        :returns: None
        &#34;&#34;&#34;
        self.context_img = None
        self.undo_manager.clear_undos()

        if self.current_patch &gt; 0:

            self.current_patch -= 1
            while self.image.patches[self.current_patch].display is False:
                self.current_patch -= 1

            self.display_current_patch()

        else:
            self.logger.error(&#34;No Previous patches&#34;)

    def change_mode(self, new_mode_id):
        &#34;&#34;&#34;
        Change the current editing mode

        :param new_mode_id: The ID of the mode button in the Main Window
        :returns: None
        &#34;&#34;&#34;
        if new_mode_id != self.main_window.ID_TOOL_NO_ROOT:
            self.main_window.zoom_cursor = False
            self.main_window.flood_cursor = False

        if new_mode_id == self.main_window.ID_TOOL_THRESH:
            self.current_mode = Mode.THRESHOLD
            self.main_window.set_brush_radius(0)
            patch = self.image.patches[self.current_patch]
            self.main_window.update_thresh_slider_value(patch.thresh)

        elif new_mode_id == self.main_window.ID_TOOL_ADD:
            self.current_mode = Mode.ADD_REGION
            self.main_window.set_brush_radius(self.add_region_radius)
            self.main_window.update_add_brush_sizer(self.add_region_radius)

        elif new_mode_id == self.main_window.ID_TOOL_REMOVE:
            self.current_mode = Mode.REMOVE_REGION
            self.main_window.set_brush_radius(self.remove_region_radius)
            self.main_window.\
                update_remove_brush_sizer(self.remove_region_radius)

        elif new_mode_id == self.main_window.ID_TOOL_NO_ROOT:
            self.no_root_activate()

        elif new_mode_id == self.main_window.ID_TOOL_FLOOD_ADD:
            self.current_mode = Mode.FLOOD_ADD
            self.main_window.flood_cursor = True
            self.flood_add_position = None
            # self.flood_add_tolerance = 0.05
            self.main_window.\
                update_flood_add_slider_value(self.flood_add_tolerance)

        elif new_mode_id == self.main_window.ID_TOOL_FLOOD_REMOVE:
            self.current_mode = Mode.FLOOD_REMOVE
            self.main_window.flood_cursor = True
            self.flood_remove_position = None
            # self.flood_remove_tolerance = 0.05
            self.main_window.\
                update_flood_remove_slider_value(self.flood_remove_tolerance)

        elif new_mode_id == self.main_window.ID_TOOL_ADD_TIP:
            self.current_mode = Mode.ADD_TIP
            self.main_window.flood_cursor = True

        elif new_mode_id == self.main_window.ID_TOOL_ADD_BRANCH:
            self.current_mode = Mode.ADD_BRANCH
            self.main_window.flood_cursor = True

        elif new_mode_id == self.main_window.ID_TOOL_ADD_CROSS:
            self.current_mode = Mode.ADD_CROSSING
            self.main_window.flood_cursor = True

        elif new_mode_id == self.main_window.ID_TOOL_REMOVE_LANDMARK:
            self.current_mode = Mode.REMOVE_LANDMARK
            self.main_window.set_brush_radius(self.remove_landmark_radius)

        else:
            self.logger.error(&#34;Invalid mode change&#34;)

            return False

    def change_secondary_mode(self, new_mode_id):
        &#34;&#34;&#34;
        Change the secondary mode (for mouse wheel tool adjustments)

        :param new_mode_id: The id of the new mode
        :returns: None
        &#34;&#34;&#34;

        if new_mode_id == self.main_window.ID_TOOL_ZOOM:
            self.current_secondary_mode = SecondaryMode.ZOOM

        elif new_mode_id == self.main_window.ID_ADJUST_TOOL:
            self.current_secondary_mode = SecondaryMode.ADJUST_TOOL

    def no_root_activate(self):
        &#34;&#34;&#34;
        Set the mask for the patch to zero, there is no root here

        :returns: None
        &#34;&#34;&#34;
        patch = self.image.patches[self.current_patch]

        self.undo_manager.add_to_undo_stack(copy.deepcopy(patch), &#39;no_root&#39;)

        patch.clear_mask()
        patch.overlay_mask()

        self.display_current_patch()

    def handle_mouse_wheel(self, wheel_rotation, x, y):
        &#34;&#34;&#34;
        Handle wheel rotation coming from the mouse

        :param wheel_rotation: The wheel rotation
        :param x: The x-position of the mouse event
        :param y: The y-position of the mouse event
        :returns: True on success, False otherwise
        &#34;&#34;&#34;

        if self.current_secondary_mode == SecondaryMode.ADJUST_TOOL:
            if self.current_mode == Mode.THRESHOLD:

                self.adjust_threshold(wheel_rotation)

            elif self.current_mode == Mode.ADD_REGION:
                self.adjust_add_region_brush(wheel_rotation)

            elif self.current_mode == Mode.REMOVE_REGION:
                self.adjust_remove_region_brush(wheel_rotation)

            elif self.current_mode == Mode.REMOVE_LANDMARK:
                self.adjust_remove_landmark_brush(wheel_rotation)

            elif self.current_mode == Mode.FLOOD_ADD:
                self.handle_flood_add_tolerance(wheel_rotation)

            elif self.current_mode == Mode.FLOOD_REMOVE:
                self.handle_flood_remove_tolerance(wheel_rotation)
            else:
                return False

        elif self.current_secondary_mode == SecondaryMode.ZOOM:
            self.handle_zoom(wheel_rotation, x, y)

        else:
            self.logger.error(&#34;Invalid mouse wheel rotation&#34;)
            return False

        return True

    def handle_flood_add_tolerance(self, wheel_rotation):
        &#34;&#34;&#34;
        Adjust the current tolerance of the flood_add tool

        :param wheel_rotation: The rotation of the mouse wheel
        :returns: None
        &#34;&#34;&#34;

        if self.flood_add_position is None:
            return

        if wheel_rotation &gt; 0:
            self.flood_add_tolerance += 0.01
        elif wheel_rotation &lt; 0:
            self.flood_add_tolerance -= 0.01

        patch = self.image.patches[self.current_patch]

        patch.flood_add_region(self.flood_add_position,
                               self.flood_add_tolerance)

        patch.overlay_mask()
        self.display_current_patch()

    def set_flood_add_tolerance(self, value):
        &#34;&#34;&#34;
        Set the current flood add tolerance

        :param value: The value to set it to
        :returns: None
        &#34;&#34;&#34;

        if self.flood_add_position is None:
            return

        self.flood_add_tolerance = value

        patch = self.image.patches[self.current_patch]

        patch.flood_add_region(self.flood_add_position,
                               self.flood_add_tolerance)

        patch.overlay_mask()
        self.display_current_patch()

    def handle_flood_remove_tolerance(self, wheel_rotation):
        &#34;&#34;&#34;
        Adjust the current tolerance of the flood_remove tool

        :param wheel_rotation: The rotation of the mouse wheel
        :returns: None
        &#34;&#34;&#34;

        if self.flood_remove_position is None:
            return

        if wheel_rotation &gt; 0:
            self.flood_remove_tolerance += 0.01
        elif wheel_rotation &lt; 0:
            self.flood_remove_tolerance -= 0.01

        patch = self.image.patches[self.current_patch]

        patch.flood_remove_region(self.flood_remove_position,
                                  self.flood_remove_tolerance)

        patch.overlay_mask()
        self.display_current_patch()

    def set_flood_remove_tolerance(self, value):
        &#34;&#34;&#34;
        Set the current flood remove tolerance

        :param value: The value to set it to
        :returns: None
        &#34;&#34;&#34;

        if self.flood_remove_position is None:
            return

        self.flood_remove_tolerance = value

        patch = self.image.patches[self.current_patch]

        patch.flood_remove_region(self.flood_remove_position,
                                  self.flood_remove_tolerance)

        patch.overlay_mask()
        self.display_current_patch()

    def handle_zoom(self, wheel_rotation, x, y):
        &#34;&#34;&#34;
        Handle zooming with the mouse wheel

        :param wheel_rotation: The roation of the mouse wheel
        :param x: The x-cooridinate
        :param y: The y-coordinate
        :returns: True on success, False otherwise
        &#34;&#34;&#34;

        old_scale = self.main_window.image_scale

        img_point = (x - self.main_window.image_x,
                     y - self.main_window.image_y)

        img_point = (img_point[0] / self.main_window.image_scale,
                     img_point[1] / self.main_window.image_scale)

        if wheel_rotation &gt; 0 and old_scale &lt; self.main_window.MAX_SCALE:
            self.main_window.image_scale *= self.ZOOM_SCALE
            new_img_point = (img_point[0] * self.ZOOM_SCALE, img_point[1] *
                             self.ZOOM_SCALE)

            translation = (new_img_point[0] - img_point[0],
                           new_img_point[1] - img_point[1])

            self.main_window.image_x -= translation[0]
            self.main_window.image_y -= translation[1]

        elif wheel_rotation &lt; 0 and old_scale &gt; self.main_window.MIN_SCALE:
            self.main_window.image_scale /= self.ZOOM_SCALE
            new_img_point = (img_point[0] / self.ZOOM_SCALE, img_point[1] /
                             self.ZOOM_SCALE)

            translation = (new_img_point[0] - img_point[0],
                           new_img_point[1] - img_point[1])

            self.main_window.image_x -= translation[0]
            self.main_window.image_y -= translation[1]

        else:
            return False

        self.logger.debug(&#34;Image Scale: {}&#34;.
                          format(self.main_window.image_scale))
        self.display_current_patch()
        return True

    def handle_left_click(self, click_location):
        &#34;&#34;&#34;
        Handle a left mouse click at the given location

        :param click_location: The location (x, y) of the click
        :returns: True on success, False otherwise
        &#34;&#34;&#34;

        click_location = self.convert_click_to_image_position(click_location)

        if click_location is None:
            return False

        if self.current_mode == Mode.ADD_REGION:
            self.logger.debug(&#34;Add region click {}&#34;.format(click_location))

            draw_radius = self.add_region_radius / self.main_window.image_scale

            patch = self.image.patches[self.current_patch]

            self.undo_manager.add_to_undo_stack(copy.deepcopy(patch),
                                                &#39;add_region&#39;)

            patch.add_region(click_location, draw_radius)

            self.display_current_patch()

        elif self.current_mode == Mode.REMOVE_REGION:
            self.logger.debug(&#34;Remove region click&#34;)

            draw_radius = (self.remove_region_radius /
                           self.main_window.image_scale)

            patch = self.image.patches[self.current_patch]

            self.undo_manager.add_to_undo_stack(copy.deepcopy(patch),
                                                &#39;remove_region&#39;)

            patch.remove_region(click_location, draw_radius)
            self.display_current_patch()

        elif self.current_mode == Mode.ADD_TIP:

            patch = self.image.patches[self.current_patch]
            patch.add_landmark(click_location, self.add_tip_radius,
                               self.image.TIP_LABEL)
            self.display_current_patch()

        elif self.current_mode == Mode.ADD_CROSSING:
            patch = self.image.patches[self.current_patch]
            patch.add_landmark(click_location, self.add_cross_radius,
                               self.image.CROSS_LABEL)
            self.display_current_patch()

        elif self.current_mode == Mode.ADD_BRANCH:
            patch = self.image.patches[self.current_patch]
            patch.add_landmark(click_location, self.add_branch_radius,
                               self.image.BRANCH_LABEL)
            self.display_current_patch()

        elif self.current_mode == Mode.REMOVE_LANDMARK:
            draw_radius = (self.remove_landmark_radius /
                           self.main_window.image_scale)

            patch = self.image.patches[self.current_patch]
            patch.remove_landmark(click_location, draw_radius)
            self.display_current_patch()

        elif self.current_mode == Mode.FLOOD_ADD:

            patch = self.image.patches[self.current_patch]

            self.undo_manager.add_to_undo_stack(copy.deepcopy(patch),
                                                &#39;flood_add&#39;)

            patch.flood_add_region(click_location, self.flood_add_tolerance)

            self.flood_add_position = click_location

            self.display_current_patch()

        elif self.current_mode == Mode.FLOOD_REMOVE:
            patch = self.image.patches[self.current_patch]

            self.undo_manager.add_to_undo_stack(copy.deepcopy(patch),
                                                &#39;flood_remove&#39;)

            patch.flood_remove_region(click_location,
                                      self.flood_remove_tolerance)

            self.flood_remove_position = click_location

            self.display_current_patch()

        else:
            return False

        return True

    def handle_right_click(self):
        &#34;&#34;&#34;
        Called when the right mouse button is clickd

        :returns: None
        &#34;&#34;&#34;
        self.logger.debug(&#34;Right click&#34;)

    def handle_left_release(self):
        &#34;&#34;&#34;
        Handle the release of the left mouse button

        :returns: True on success, False otherwise
        &#34;&#34;&#34;

        if self.current_mode == Mode.ADD_REGION:
            self.logger.debug(&#34;Add region release&#34;)
            return True

        elif self.current_mode == Mode.REMOVE_REGION:
            self.logger.debug(&#34;Remove region release&#34;)
            return True
        else:
            return False

    def handle_motion(self, position):
        &#34;&#34;&#34;
        Handle motion events of the mouse at the given position

        :param position: The position (x, y) of the mouse during the event
        :returns: True on success, False otherwise
        &#34;&#34;&#34;
        position = self.convert_click_to_image_position(position)

        if position is None:
            return False

        if self.current_mode == Mode.ADD_REGION:
            self.logger.debug(&#34;Adding region&#34;)

            draw_radius = self.add_region_radius / self.main_window.image_scale

            patch = self.image.patches[self.current_patch]

            self.undo_manager.add_to_undo_stack(copy.deepcopy(patch),
                                                &#39;add_region_adjust&#39;)

            patch.add_region(position, draw_radius)

            self.display_current_patch()

        elif self.current_mode == Mode.REMOVE_REGION:
            self.logger.debug(&#34;Removing Region&#34;)

            draw_radius = (self.remove_region_radius /
                           self.main_window.image_scale)

            patch = self.image.patches[self.current_patch]

            self.undo_manager.add_to_undo_stack(copy.deepcopy(patch),
                                                &#39;remove_region_adjust&#39;)

            patch.remove_region(position, draw_radius)
            self.display_current_patch()

        elif self.current_mode == Mode.REMOVE_LANDMARK:
            draw_radius = (self.remove_landmark_radius /
                           self.main_window.image_scale)

            patch = self.image.patches[self.current_patch]
            patch.remove_landmark(position, draw_radius)
            self.display_current_patch()

        else:
            return False

        return True

    def handle_mouse_wheel_motion(self, position):
        &#34;&#34;&#34;
        Handle when the mouse wheel is clicked and the mouse is dragged

        :param position: The position of the mouse
        :returns: None
        &#34;&#34;&#34;

        if self.current_secondary_mode == SecondaryMode.ZOOM:
            self.main_window.image_x += (position[0] -
                                         self.main_window.previous_position[0])

            self.main_window.image_y += (position[1] -
                                         self.main_window.previous_position[1])

            self.display_current_patch()

    def adjust_threshold(self, wheel_rotation):
        &#34;&#34;&#34;
        Adjust the current threshold of the patch mask

        :param wheel_rotation: The rotation of the mouse wheel
        :returns: None
        &#34;&#34;&#34;

        patch = self.image.patches[self.current_patch]

        self.undo_manager.add_to_undo_stack(copy.deepcopy(patch),
                                            &#39;threshold_adjust&#39;)

        # Adjust the threshold.  Note that it is inverted, because it feels
        # more natural to scroll down to &#39;reduce&#39; the region, rather than
        # reducing the threshold
        if wheel_rotation &gt; 0 and patch.thresh &gt; 0:
            patch.thresh -= 0.01

        elif wheel_rotation &lt; 0 and patch.thresh &lt; 1:

            patch.thresh += 0.01

        self.main_window.update_thresh_slider_value(patch.thresh)
        self.main_window.update_add_brush_sizer(self.add_region_radius)
        patch.apply_threshold(patch.thresh)
        patch.overlay_mask()

        self.logger.debug(&#34;Threshold value: {}&#34;.format(patch.thresh))
        self.display_current_patch()

    def set_threshold(self, value):
        &#34;&#34;&#34;
        Set the value of the threshold

        :param value: Value for the threshold
        :returns: Nonw
        &#34;&#34;&#34;

        patch = self.image.patches[self.current_patch]

        self.undo_manager.add_to_undo_stack(copy.deepcopy(patch),
                                            &#39;threshold_adjust&#39;)

        patch.thresh = value
        patch.apply_threshold(patch.thresh)
        patch.overlay_mask()

        self.display_current_patch()

    def adjust_add_region_brush(self, wheel_rotation):
        &#34;&#34;&#34;
        Adjust the size of the region brush

        :param wheel_rotation: The rotation of the mouse wheel
        :returns: None
        &#34;&#34;&#34;

        self.logger.debug(&#34;Adjusting add region brush&#34;)
        if wheel_rotation &gt; 0:
            self.add_region_radius += 1
        else:
            self.add_region_radius -= 1

        self.main_window.update_add_brush_sizer(self.add_region_radius)
        self.main_window.set_brush_radius(self.add_region_radius)
        self.main_window.draw_brush()

    def set_add_region_brush(self, value):
        &#34;&#34;&#34;
        Set the value of the add region brush size

        :param value: The size
        :returns: None
        &#34;&#34;&#34;

        self.add_region_radius = value

        self.main_window.set_brush_radius(self.add_region_radius)
        self.main_window.draw_brush()

    def adjust_remove_landmark_brush(self, wheel_rotation):
        &#34;&#34;&#34;
        Adjust the size of the remove landmark brush

        :param wheel_rotation: The rotation of the mouse wheel
        :returns: None
        &#34;&#34;&#34;

        if wheel_rotation &gt; 0:
            self.remove_landmark_radius += 1
        else:
            self.remove_landmark_radius -= 1

        self.main_window.set_brush_radius(self.remove_landmark_radius)
        self.main_window.draw_brush()

    def adjust_remove_region_brush(self, wheel_rotation):
        &#34;&#34;&#34;
        Adjust the size of the remove region brush

        :param wheel_rotation: the rotation of the mouse wheel
        :returns: None
        &#34;&#34;&#34;

        self.logger.debug(&#34;Adjusting the remove region brush&#34;)
        if wheel_rotation &gt; 0:
            self.remove_region_radius += 1
        else:
            self.remove_region_radius -= 1

        self.main_window.update_remove_brush_sizer(self.remove_region_radius)
        self.main_window.set_brush_radius(self.remove_region_radius)
        self.main_window.draw_brush()

    def set_remove_region_brush(self, value):
        &#34;&#34;&#34;
        Set the value of the remove region brush size

        :param value: The value
        :returns: None
        &#34;&#34;&#34;
        self.remove_region_radius = value

        self.main_window.set_brush_radius(self.remove_region_radius)
        self.main_window.draw_brush()

    def undo(self):

        patch = self.image.patches[self.current_patch]

        redo_patch, operation = self.undo_manager.undo()

        if redo_patch is None:
            return

        self.undo_manager.add_to_redo_stack(patch, operation)
        self.main_window.toolbar_buttons[self.main_window.ID_TOOL_REDO]\
            .config(state=&#34;normal&#34;)

        self.image.patches[self.current_patch] = redo_patch

        self.display_current_patch()

    def redo(self):

        patch = self.image.patches[self.current_patch]

        undo_patch, operation = self.undo_manager.redo()

        if undo_patch is None:
            return

        self.undo_manager.add_to_undo_stack(patch, operation)
        if len(self.undo_manager.redo_stack) == 0:
            self.main_window.toolbar_buttons[self.main_window.ID_TOOL_REDO]\
                .config(state=&#34;disabled&#34;)

        self.image.patches[self.current_patch] = undo_patch

        self.display_current_patch()</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="friendly_ground_truth.controller.controller.Controller.CONTEXT_TRANSPARENCY"><code class="name">var <span class="ident">CONTEXT_TRANSPARENCY</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="friendly_ground_truth.controller.controller.Controller.ZOOM_SCALE"><code class="name">var <span class="ident">ZOOM_SCALE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="friendly_ground_truth.controller.controller.Controller.adjust_add_region_brush"><code class="name flex">
<span>def <span class="ident">adjust_add_region_brush</span></span>(<span>self, wheel_rotation)</span>
</code></dt>
<dd>
<div class="desc"><p>Adjust the size of the region brush</p>
<p>:param wheel_rotation: The rotation of the mouse wheel
:returns: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def adjust_add_region_brush(self, wheel_rotation):
    &#34;&#34;&#34;
    Adjust the size of the region brush

    :param wheel_rotation: The rotation of the mouse wheel
    :returns: None
    &#34;&#34;&#34;

    self.logger.debug(&#34;Adjusting add region brush&#34;)
    if wheel_rotation &gt; 0:
        self.add_region_radius += 1
    else:
        self.add_region_radius -= 1

    self.main_window.update_add_brush_sizer(self.add_region_radius)
    self.main_window.set_brush_radius(self.add_region_radius)
    self.main_window.draw_brush()</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.controller.controller.Controller.adjust_remove_landmark_brush"><code class="name flex">
<span>def <span class="ident">adjust_remove_landmark_brush</span></span>(<span>self, wheel_rotation)</span>
</code></dt>
<dd>
<div class="desc"><p>Adjust the size of the remove landmark brush</p>
<p>:param wheel_rotation: The rotation of the mouse wheel
:returns: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def adjust_remove_landmark_brush(self, wheel_rotation):
    &#34;&#34;&#34;
    Adjust the size of the remove landmark brush

    :param wheel_rotation: The rotation of the mouse wheel
    :returns: None
    &#34;&#34;&#34;

    if wheel_rotation &gt; 0:
        self.remove_landmark_radius += 1
    else:
        self.remove_landmark_radius -= 1

    self.main_window.set_brush_radius(self.remove_landmark_radius)
    self.main_window.draw_brush()</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.controller.controller.Controller.adjust_remove_region_brush"><code class="name flex">
<span>def <span class="ident">adjust_remove_region_brush</span></span>(<span>self, wheel_rotation)</span>
</code></dt>
<dd>
<div class="desc"><p>Adjust the size of the remove region brush</p>
<p>:param wheel_rotation: the rotation of the mouse wheel
:returns: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def adjust_remove_region_brush(self, wheel_rotation):
    &#34;&#34;&#34;
    Adjust the size of the remove region brush

    :param wheel_rotation: the rotation of the mouse wheel
    :returns: None
    &#34;&#34;&#34;

    self.logger.debug(&#34;Adjusting the remove region brush&#34;)
    if wheel_rotation &gt; 0:
        self.remove_region_radius += 1
    else:
        self.remove_region_radius -= 1

    self.main_window.update_remove_brush_sizer(self.remove_region_radius)
    self.main_window.set_brush_radius(self.remove_region_radius)
    self.main_window.draw_brush()</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.controller.controller.Controller.adjust_threshold"><code class="name flex">
<span>def <span class="ident">adjust_threshold</span></span>(<span>self, wheel_rotation)</span>
</code></dt>
<dd>
<div class="desc"><p>Adjust the current threshold of the patch mask</p>
<p>:param wheel_rotation: The rotation of the mouse wheel
:returns: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def adjust_threshold(self, wheel_rotation):
    &#34;&#34;&#34;
    Adjust the current threshold of the patch mask

    :param wheel_rotation: The rotation of the mouse wheel
    :returns: None
    &#34;&#34;&#34;

    patch = self.image.patches[self.current_patch]

    self.undo_manager.add_to_undo_stack(copy.deepcopy(patch),
                                        &#39;threshold_adjust&#39;)

    # Adjust the threshold.  Note that it is inverted, because it feels
    # more natural to scroll down to &#39;reduce&#39; the region, rather than
    # reducing the threshold
    if wheel_rotation &gt; 0 and patch.thresh &gt; 0:
        patch.thresh -= 0.01

    elif wheel_rotation &lt; 0 and patch.thresh &lt; 1:

        patch.thresh += 0.01

    self.main_window.update_thresh_slider_value(patch.thresh)
    self.main_window.update_add_brush_sizer(self.add_region_radius)
    patch.apply_threshold(patch.thresh)
    patch.overlay_mask()

    self.logger.debug(&#34;Threshold value: {}&#34;.format(patch.thresh))
    self.display_current_patch()</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.controller.controller.Controller.change_mode"><code class="name flex">
<span>def <span class="ident">change_mode</span></span>(<span>self, new_mode_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Change the current editing mode</p>
<p>:param new_mode_id: The ID of the mode button in the Main Window
:returns: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def change_mode(self, new_mode_id):
    &#34;&#34;&#34;
    Change the current editing mode

    :param new_mode_id: The ID of the mode button in the Main Window
    :returns: None
    &#34;&#34;&#34;
    if new_mode_id != self.main_window.ID_TOOL_NO_ROOT:
        self.main_window.zoom_cursor = False
        self.main_window.flood_cursor = False

    if new_mode_id == self.main_window.ID_TOOL_THRESH:
        self.current_mode = Mode.THRESHOLD
        self.main_window.set_brush_radius(0)
        patch = self.image.patches[self.current_patch]
        self.main_window.update_thresh_slider_value(patch.thresh)

    elif new_mode_id == self.main_window.ID_TOOL_ADD:
        self.current_mode = Mode.ADD_REGION
        self.main_window.set_brush_radius(self.add_region_radius)
        self.main_window.update_add_brush_sizer(self.add_region_radius)

    elif new_mode_id == self.main_window.ID_TOOL_REMOVE:
        self.current_mode = Mode.REMOVE_REGION
        self.main_window.set_brush_radius(self.remove_region_radius)
        self.main_window.\
            update_remove_brush_sizer(self.remove_region_radius)

    elif new_mode_id == self.main_window.ID_TOOL_NO_ROOT:
        self.no_root_activate()

    elif new_mode_id == self.main_window.ID_TOOL_FLOOD_ADD:
        self.current_mode = Mode.FLOOD_ADD
        self.main_window.flood_cursor = True
        self.flood_add_position = None
        # self.flood_add_tolerance = 0.05
        self.main_window.\
            update_flood_add_slider_value(self.flood_add_tolerance)

    elif new_mode_id == self.main_window.ID_TOOL_FLOOD_REMOVE:
        self.current_mode = Mode.FLOOD_REMOVE
        self.main_window.flood_cursor = True
        self.flood_remove_position = None
        # self.flood_remove_tolerance = 0.05
        self.main_window.\
            update_flood_remove_slider_value(self.flood_remove_tolerance)

    elif new_mode_id == self.main_window.ID_TOOL_ADD_TIP:
        self.current_mode = Mode.ADD_TIP
        self.main_window.flood_cursor = True

    elif new_mode_id == self.main_window.ID_TOOL_ADD_BRANCH:
        self.current_mode = Mode.ADD_BRANCH
        self.main_window.flood_cursor = True

    elif new_mode_id == self.main_window.ID_TOOL_ADD_CROSS:
        self.current_mode = Mode.ADD_CROSSING
        self.main_window.flood_cursor = True

    elif new_mode_id == self.main_window.ID_TOOL_REMOVE_LANDMARK:
        self.current_mode = Mode.REMOVE_LANDMARK
        self.main_window.set_brush_radius(self.remove_landmark_radius)

    else:
        self.logger.error(&#34;Invalid mode change&#34;)

        return False</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.controller.controller.Controller.change_secondary_mode"><code class="name flex">
<span>def <span class="ident">change_secondary_mode</span></span>(<span>self, new_mode_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Change the secondary mode (for mouse wheel tool adjustments)</p>
<p>:param new_mode_id: The id of the new mode
:returns: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def change_secondary_mode(self, new_mode_id):
    &#34;&#34;&#34;
    Change the secondary mode (for mouse wheel tool adjustments)

    :param new_mode_id: The id of the new mode
    :returns: None
    &#34;&#34;&#34;

    if new_mode_id == self.main_window.ID_TOOL_ZOOM:
        self.current_secondary_mode = SecondaryMode.ZOOM

    elif new_mode_id == self.main_window.ID_ADJUST_TOOL:
        self.current_secondary_mode = SecondaryMode.ADJUST_TOOL</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.controller.controller.Controller.convert_click_to_image_position"><code class="name flex">
<span>def <span class="ident">convert_click_to_image_position</span></span>(<span>self, click_location)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert a click location to coordinates in the image</p>
<p>:param click_location: (x, y) coords of the click
:returns: The corresponding coordinates in the image</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convert_click_to_image_position(self, click_location):
    &#34;&#34;&#34;
    Convert a click location to coordinates in the image

    :param click_location: (x, y) coords of the click
    :returns: The corresponding coordinates in the image
    &#34;&#34;&#34;
    click_location = (click_location[0] - self.main_window.image_x,
                      click_location[1] - self.main_window.image_y)

    click_location = (click_location[0] / self.main_window.image_scale,
                      click_location[1] / self.main_window.image_scale)

    click_location = (click_location[0] - self.patch_offset[1],
                      click_location[1] - self.patch_offset[0])

    # Make sure we are clicking on the image
    if click_location[0] &lt; 0 or click_location[1] &lt; 0:
        return None

    return click_location</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.controller.controller.Controller.display_current_patch"><code class="name flex">
<span>def <span class="ident">display_current_patch</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Display the current patch to be displayed</p>
<p>:returns: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def display_current_patch(self):
    &#34;&#34;&#34;
    Display the current patch to be displayed

    :returns: None
    &#34;&#34;&#34;
    if self.image is None:
        return

    patch = self.image.patches[self.current_patch]
    img = self.get_context_patches(patch)

    self.main_window.update_tool = False
    self.main_window.update_thresh_slider_value(patch.thresh)
    self.main_window.update_add_brush_sizer(self.add_region_radius)
    self.main_window.update_remove_brush_sizer(self.remove_region_radius)
    self.main_window.\
        update_flood_add_slider_value(self.flood_add_tolerance)
    self.main_window.\
        update_flood_remove_slider_value(self.flood_remove_tolerance)
    self.main_window.set_brush_radius
    self.main_window.show_image(img)</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.controller.controller.Controller.get_context_patches"><code class="name flex">
<span>def <span class="ident">get_context_patches</span></span>(<span>self, patch)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the patches immediately surrounding the current patch and place
them in a larger image</p>
<p>:param patch: The current patch
:returns: A matrix of patches for display</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_context_patches(self, patch):
    &#34;&#34;&#34;
    Get the patches immediately surrounding the current patch and place
    them in a larger image

    :param patch: The current patch
    :returns: A matrix of patches for display
    &#34;&#34;&#34;

    # Find the neighbouring patches
    index = patch.patch_index

    if self.context_img is not None:
        patch = self.image.patches[self.current_patch]
        r_start = self.patch_offset[0]
        r_end = r_start + patch.overlay_image.shape[0]
        c_start = self.patch_offset[1]
        c_end = c_start + patch.overlay_image.shape[1]

        o_img = patch.overlay_image
        o_img = np.dstack((o_img, np.full(o_img.shape[0:-1],
                           255, dtype=o_img.dtype)))
        self.logger.debug(&#34;Using cached context image&#34;)

        self.context_img[r_start:r_end, c_start:c_end] = o_img
        return self.context_img

    neighbouring_indices = []

    start_i = index[0] - 1
    start_j = index[1] - 1

    num_rows = 0
    num_cols = 0

    for i in range(start_i, start_i + 3):

        if i &lt; 0 or i &gt;= self.image.NUM_PATCHES:
            self.logger.debug(&#34;Patch Out Of Bounds&#34;)
            continue
        for j in range(start_j, start_j + 3):
            if j &lt; 0 or j &gt;= self.image.NUM_PATCHES:
                self.logger.debug(&#34;Patch Out Of Bounds&#34;)
                continue

            neighbouring_indices.append((i, j))

            if num_rows == 0:
                num_cols += 1
        num_rows += 1

    neighbouring_patches = []
    drawable_patch_index = None  # Index of our patch in this list

    # TODO: This could be more efficient I&#39;m sure
    for i in neighbouring_indices:
        for patch in self.image.patches:
            if patch.patch_index == i:
                o_img = patch.overlay_image

                if i == index:
                    o_img = np.dstack((o_img, np.full(o_img.shape[0:-1],
                                       255,
                                       dtype=o_img.dtype)))
                    drawable_patch_index = neighbouring_indices.index(i)
                else:
                    o_img = np.dstack((o_img, np.full(o_img.shape[0:-1],
                                       self.CONTEXT_TRANSPARENCY,
                                       dtype=o_img.dtype)))

                neighbouring_patches.append(o_img)

    # Layer them into a numpy array
    img_shape = (patch.overlay_image.shape[0] * num_rows,
                 patch.overlay_image.shape[1] * num_cols, 4)
    img = np.zeros(img_shape, dtype=np.ubyte)

    col_num = 0
    row_num = 0

    i = 0
    for patch in neighbouring_patches:
        r, c = row_num, col_num
        r = r * patch.shape[0]
        c = c * patch.shape[1]
        img[r:r+patch.shape[0],
            c:c+patch.shape[1]] += patch
        if i == drawable_patch_index:
            self.patch_offset = (r, c)

        col_num += 1

        if col_num == num_cols:
            col_num = 0
            row_num += 1

        i += 1

    self.context_img = img
    return img</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.controller.controller.Controller.get_image_name_from_path"><code class="name flex">
<span>def <span class="ident">get_image_name_from_path</span></span>(<span>self, path)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the filename from the image to use for saving the mask</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong></dt>
<dd>The path to the original image</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>The new filename for the mask</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_image_name_from_path(self, path):
    &#34;&#34;&#34;
    Get the filename from the image to use for saving the mask

    Args:
        path: The path to the original image
    Returns:
        The new filename for the mask
    &#34;&#34;&#34;

    if os.path.isdir(path):
        raise ValueError(&#34;Cannot get image name from a directory.&#34;)

    basename = os.path.basename(path)
    return os.path.splitext(basename)[0] + &#39;_mask.png&#39;</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.controller.controller.Controller.get_landmark_name_from_path"><code class="name flex">
<span>def <span class="ident">get_landmark_name_from_path</span></span>(<span>self, path)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the name of the landmark matrix to use for saving</p>
<p>:param path: The path to the original image
:returns: The new filename for the mask</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_landmark_name_from_path(self, path):
    &#34;&#34;&#34;
    Get the name of the landmark matrix to use for saving

    :param path: The path to the original image
    :returns: The new filename for the mask
    &#34;&#34;&#34;

    if os.path.isdir(path):
        raise ValueError(&#34;Cannot get image name from a directory&#34;)

    basename = os.path.basename(path)
    return os.path.splitext(basename)[0] + &#39;_labels.npy&#39;</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.controller.controller.Controller.handle_flood_add_tolerance"><code class="name flex">
<span>def <span class="ident">handle_flood_add_tolerance</span></span>(<span>self, wheel_rotation)</span>
</code></dt>
<dd>
<div class="desc"><p>Adjust the current tolerance of the flood_add tool</p>
<p>:param wheel_rotation: The rotation of the mouse wheel
:returns: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_flood_add_tolerance(self, wheel_rotation):
    &#34;&#34;&#34;
    Adjust the current tolerance of the flood_add tool

    :param wheel_rotation: The rotation of the mouse wheel
    :returns: None
    &#34;&#34;&#34;

    if self.flood_add_position is None:
        return

    if wheel_rotation &gt; 0:
        self.flood_add_tolerance += 0.01
    elif wheel_rotation &lt; 0:
        self.flood_add_tolerance -= 0.01

    patch = self.image.patches[self.current_patch]

    patch.flood_add_region(self.flood_add_position,
                           self.flood_add_tolerance)

    patch.overlay_mask()
    self.display_current_patch()</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.controller.controller.Controller.handle_flood_remove_tolerance"><code class="name flex">
<span>def <span class="ident">handle_flood_remove_tolerance</span></span>(<span>self, wheel_rotation)</span>
</code></dt>
<dd>
<div class="desc"><p>Adjust the current tolerance of the flood_remove tool</p>
<p>:param wheel_rotation: The rotation of the mouse wheel
:returns: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_flood_remove_tolerance(self, wheel_rotation):
    &#34;&#34;&#34;
    Adjust the current tolerance of the flood_remove tool

    :param wheel_rotation: The rotation of the mouse wheel
    :returns: None
    &#34;&#34;&#34;

    if self.flood_remove_position is None:
        return

    if wheel_rotation &gt; 0:
        self.flood_remove_tolerance += 0.01
    elif wheel_rotation &lt; 0:
        self.flood_remove_tolerance -= 0.01

    patch = self.image.patches[self.current_patch]

    patch.flood_remove_region(self.flood_remove_position,
                              self.flood_remove_tolerance)

    patch.overlay_mask()
    self.display_current_patch()</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.controller.controller.Controller.handle_left_click"><code class="name flex">
<span>def <span class="ident">handle_left_click</span></span>(<span>self, click_location)</span>
</code></dt>
<dd>
<div class="desc"><p>Handle a left mouse click at the given location</p>
<p>:param click_location: The location (x, y) of the click
:returns: True on success, False otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_left_click(self, click_location):
    &#34;&#34;&#34;
    Handle a left mouse click at the given location

    :param click_location: The location (x, y) of the click
    :returns: True on success, False otherwise
    &#34;&#34;&#34;

    click_location = self.convert_click_to_image_position(click_location)

    if click_location is None:
        return False

    if self.current_mode == Mode.ADD_REGION:
        self.logger.debug(&#34;Add region click {}&#34;.format(click_location))

        draw_radius = self.add_region_radius / self.main_window.image_scale

        patch = self.image.patches[self.current_patch]

        self.undo_manager.add_to_undo_stack(copy.deepcopy(patch),
                                            &#39;add_region&#39;)

        patch.add_region(click_location, draw_radius)

        self.display_current_patch()

    elif self.current_mode == Mode.REMOVE_REGION:
        self.logger.debug(&#34;Remove region click&#34;)

        draw_radius = (self.remove_region_radius /
                       self.main_window.image_scale)

        patch = self.image.patches[self.current_patch]

        self.undo_manager.add_to_undo_stack(copy.deepcopy(patch),
                                            &#39;remove_region&#39;)

        patch.remove_region(click_location, draw_radius)
        self.display_current_patch()

    elif self.current_mode == Mode.ADD_TIP:

        patch = self.image.patches[self.current_patch]
        patch.add_landmark(click_location, self.add_tip_radius,
                           self.image.TIP_LABEL)
        self.display_current_patch()

    elif self.current_mode == Mode.ADD_CROSSING:
        patch = self.image.patches[self.current_patch]
        patch.add_landmark(click_location, self.add_cross_radius,
                           self.image.CROSS_LABEL)
        self.display_current_patch()

    elif self.current_mode == Mode.ADD_BRANCH:
        patch = self.image.patches[self.current_patch]
        patch.add_landmark(click_location, self.add_branch_radius,
                           self.image.BRANCH_LABEL)
        self.display_current_patch()

    elif self.current_mode == Mode.REMOVE_LANDMARK:
        draw_radius = (self.remove_landmark_radius /
                       self.main_window.image_scale)

        patch = self.image.patches[self.current_patch]
        patch.remove_landmark(click_location, draw_radius)
        self.display_current_patch()

    elif self.current_mode == Mode.FLOOD_ADD:

        patch = self.image.patches[self.current_patch]

        self.undo_manager.add_to_undo_stack(copy.deepcopy(patch),
                                            &#39;flood_add&#39;)

        patch.flood_add_region(click_location, self.flood_add_tolerance)

        self.flood_add_position = click_location

        self.display_current_patch()

    elif self.current_mode == Mode.FLOOD_REMOVE:
        patch = self.image.patches[self.current_patch]

        self.undo_manager.add_to_undo_stack(copy.deepcopy(patch),
                                            &#39;flood_remove&#39;)

        patch.flood_remove_region(click_location,
                                  self.flood_remove_tolerance)

        self.flood_remove_position = click_location

        self.display_current_patch()

    else:
        return False

    return True</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.controller.controller.Controller.handle_left_release"><code class="name flex">
<span>def <span class="ident">handle_left_release</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Handle the release of the left mouse button</p>
<p>:returns: True on success, False otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_left_release(self):
    &#34;&#34;&#34;
    Handle the release of the left mouse button

    :returns: True on success, False otherwise
    &#34;&#34;&#34;

    if self.current_mode == Mode.ADD_REGION:
        self.logger.debug(&#34;Add region release&#34;)
        return True

    elif self.current_mode == Mode.REMOVE_REGION:
        self.logger.debug(&#34;Remove region release&#34;)
        return True
    else:
        return False</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.controller.controller.Controller.handle_motion"><code class="name flex">
<span>def <span class="ident">handle_motion</span></span>(<span>self, position)</span>
</code></dt>
<dd>
<div class="desc"><p>Handle motion events of the mouse at the given position</p>
<p>:param position: The position (x, y) of the mouse during the event
:returns: True on success, False otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_motion(self, position):
    &#34;&#34;&#34;
    Handle motion events of the mouse at the given position

    :param position: The position (x, y) of the mouse during the event
    :returns: True on success, False otherwise
    &#34;&#34;&#34;
    position = self.convert_click_to_image_position(position)

    if position is None:
        return False

    if self.current_mode == Mode.ADD_REGION:
        self.logger.debug(&#34;Adding region&#34;)

        draw_radius = self.add_region_radius / self.main_window.image_scale

        patch = self.image.patches[self.current_patch]

        self.undo_manager.add_to_undo_stack(copy.deepcopy(patch),
                                            &#39;add_region_adjust&#39;)

        patch.add_region(position, draw_radius)

        self.display_current_patch()

    elif self.current_mode == Mode.REMOVE_REGION:
        self.logger.debug(&#34;Removing Region&#34;)

        draw_radius = (self.remove_region_radius /
                       self.main_window.image_scale)

        patch = self.image.patches[self.current_patch]

        self.undo_manager.add_to_undo_stack(copy.deepcopy(patch),
                                            &#39;remove_region_adjust&#39;)

        patch.remove_region(position, draw_radius)
        self.display_current_patch()

    elif self.current_mode == Mode.REMOVE_LANDMARK:
        draw_radius = (self.remove_landmark_radius /
                       self.main_window.image_scale)

        patch = self.image.patches[self.current_patch]
        patch.remove_landmark(position, draw_radius)
        self.display_current_patch()

    else:
        return False

    return True</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.controller.controller.Controller.handle_mouse_wheel"><code class="name flex">
<span>def <span class="ident">handle_mouse_wheel</span></span>(<span>self, wheel_rotation, x, y)</span>
</code></dt>
<dd>
<div class="desc"><p>Handle wheel rotation coming from the mouse</p>
<p>:param wheel_rotation: The wheel rotation
:param x: The x-position of the mouse event
:param y: The y-position of the mouse event
:returns: True on success, False otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_mouse_wheel(self, wheel_rotation, x, y):
    &#34;&#34;&#34;
    Handle wheel rotation coming from the mouse

    :param wheel_rotation: The wheel rotation
    :param x: The x-position of the mouse event
    :param y: The y-position of the mouse event
    :returns: True on success, False otherwise
    &#34;&#34;&#34;

    if self.current_secondary_mode == SecondaryMode.ADJUST_TOOL:
        if self.current_mode == Mode.THRESHOLD:

            self.adjust_threshold(wheel_rotation)

        elif self.current_mode == Mode.ADD_REGION:
            self.adjust_add_region_brush(wheel_rotation)

        elif self.current_mode == Mode.REMOVE_REGION:
            self.adjust_remove_region_brush(wheel_rotation)

        elif self.current_mode == Mode.REMOVE_LANDMARK:
            self.adjust_remove_landmark_brush(wheel_rotation)

        elif self.current_mode == Mode.FLOOD_ADD:
            self.handle_flood_add_tolerance(wheel_rotation)

        elif self.current_mode == Mode.FLOOD_REMOVE:
            self.handle_flood_remove_tolerance(wheel_rotation)
        else:
            return False

    elif self.current_secondary_mode == SecondaryMode.ZOOM:
        self.handle_zoom(wheel_rotation, x, y)

    else:
        self.logger.error(&#34;Invalid mouse wheel rotation&#34;)
        return False

    return True</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.controller.controller.Controller.handle_mouse_wheel_motion"><code class="name flex">
<span>def <span class="ident">handle_mouse_wheel_motion</span></span>(<span>self, position)</span>
</code></dt>
<dd>
<div class="desc"><p>Handle when the mouse wheel is clicked and the mouse is dragged</p>
<p>:param position: The position of the mouse
:returns: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_mouse_wheel_motion(self, position):
    &#34;&#34;&#34;
    Handle when the mouse wheel is clicked and the mouse is dragged

    :param position: The position of the mouse
    :returns: None
    &#34;&#34;&#34;

    if self.current_secondary_mode == SecondaryMode.ZOOM:
        self.main_window.image_x += (position[0] -
                                     self.main_window.previous_position[0])

        self.main_window.image_y += (position[1] -
                                     self.main_window.previous_position[1])

        self.display_current_patch()</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.controller.controller.Controller.handle_right_click"><code class="name flex">
<span>def <span class="ident">handle_right_click</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Called when the right mouse button is clickd</p>
<p>:returns: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_right_click(self):
    &#34;&#34;&#34;
    Called when the right mouse button is clickd

    :returns: None
    &#34;&#34;&#34;
    self.logger.debug(&#34;Right click&#34;)</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.controller.controller.Controller.handle_zoom"><code class="name flex">
<span>def <span class="ident">handle_zoom</span></span>(<span>self, wheel_rotation, x, y)</span>
</code></dt>
<dd>
<div class="desc"><p>Handle zooming with the mouse wheel</p>
<p>:param wheel_rotation: The roation of the mouse wheel
:param x: The x-cooridinate
:param y: The y-coordinate
:returns: True on success, False otherwise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def handle_zoom(self, wheel_rotation, x, y):
    &#34;&#34;&#34;
    Handle zooming with the mouse wheel

    :param wheel_rotation: The roation of the mouse wheel
    :param x: The x-cooridinate
    :param y: The y-coordinate
    :returns: True on success, False otherwise
    &#34;&#34;&#34;

    old_scale = self.main_window.image_scale

    img_point = (x - self.main_window.image_x,
                 y - self.main_window.image_y)

    img_point = (img_point[0] / self.main_window.image_scale,
                 img_point[1] / self.main_window.image_scale)

    if wheel_rotation &gt; 0 and old_scale &lt; self.main_window.MAX_SCALE:
        self.main_window.image_scale *= self.ZOOM_SCALE
        new_img_point = (img_point[0] * self.ZOOM_SCALE, img_point[1] *
                         self.ZOOM_SCALE)

        translation = (new_img_point[0] - img_point[0],
                       new_img_point[1] - img_point[1])

        self.main_window.image_x -= translation[0]
        self.main_window.image_y -= translation[1]

    elif wheel_rotation &lt; 0 and old_scale &gt; self.main_window.MIN_SCALE:
        self.main_window.image_scale /= self.ZOOM_SCALE
        new_img_point = (img_point[0] / self.ZOOM_SCALE, img_point[1] /
                         self.ZOOM_SCALE)

        translation = (new_img_point[0] - img_point[0],
                       new_img_point[1] - img_point[1])

        self.main_window.image_x -= translation[0]
        self.main_window.image_y -= translation[1]

    else:
        return False

    self.logger.debug(&#34;Image Scale: {}&#34;.
                      format(self.main_window.image_scale))
    self.display_current_patch()
    return True</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.controller.controller.Controller.load_new_image"><code class="name flex">
<span>def <span class="ident">load_new_image</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Called when the user wants to load a new image to open a file
browser dialogue and get the image path</p>
<p>:returns: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_new_image(self):
    &#34;&#34;&#34;
    Called when the user wants to load a new image to open a file
    browser dialogue and get the image path

    :returns: None
    &#34;&#34;&#34;
    self.context_img = None
    self.logger.debug(&#34;Opening load file dialog&#34;)
    filetypes = [(&#34;TIF Files&#34;, &#34;*.tif&#34;), (&#34;TIFF Files&#34;, &#34;*.tiff&#34;),
                 (&#34;PNG Files&#34;, &#34;*.png&#34;)]

    if self.last_load_dir is None:
        initial_dir = os.path.expanduser(&#39;~&#39;)
    else:
        initial_dir = self.last_load_dir

    file_name = tkinter.filedialog.askopenfilename(filetypes=filetypes,
                                                   initialdir=initial_dir)
    if file_name is None:
        return

    self.last_load_dir = os.path.split(file_name)[0]

    self.image_path = file_name
    self.logger.debug(&#34;File: {}&#34;.format(self.image_path))
    try:
        self.main_window.start_progressbar(Image.NUM_PATCHES ** 2)
        self.image = Image(file_name, self.update_progress_bar)

    except FileNotFoundError:
        self.logger.debug(&#34;There was a problem loading the image&#34;)
        return

    self.current_patch = 0
    self.display_current_patch()</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.controller.controller.Controller.next_patch"><code class="name flex">
<span>def <span class="ident">next_patch</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Increment the current patch and display it</p>
<p>:returns: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def next_patch(self):
    &#34;&#34;&#34;
    Increment the current patch and display it

    :returns: None
    &#34;&#34;&#34;
    self.context_img = None
    self.undo_manager.clear_undos()

    if self.current_patch &lt; len(self.image.patches)-1:

        self.current_patch += 1
        while self.image.patches[self.current_patch].display is False:
            self.current_patch += 1

        self.display_current_patch()
    else:

        if self.mask_saved:
            return

        self.logger.error(&#34;No More Patches&#34;)

        dialog_message = &#34;No More Patches - Would you like to save the&#34; \
                         &#34; mask?&#34;

        dialog_title = &#34;No More Patches&#34;

        result = tkinter.messagebox.askyesno(title=dialog_title,
                                             message=dialog_message)
        self.logger.debug(result)
        if result:
            self.show_saved_preview()</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.controller.controller.Controller.no_root_activate"><code class="name flex">
<span>def <span class="ident">no_root_activate</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the mask for the patch to zero, there is no root here</p>
<p>:returns: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def no_root_activate(self):
    &#34;&#34;&#34;
    Set the mask for the patch to zero, there is no root here

    :returns: None
    &#34;&#34;&#34;
    patch = self.image.patches[self.current_patch]

    self.undo_manager.add_to_undo_stack(copy.deepcopy(patch), &#39;no_root&#39;)

    patch.clear_mask()
    patch.overlay_mask()

    self.display_current_patch()</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.controller.controller.Controller.prev_patch"><code class="name flex">
<span>def <span class="ident">prev_patch</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Decrement the current patch and display it</p>
<p>:returns: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prev_patch(self):
    &#34;&#34;&#34;
    Decrement the current patch and display it

    :returns: None
    &#34;&#34;&#34;
    self.context_img = None
    self.undo_manager.clear_undos()

    if self.current_patch &gt; 0:

        self.current_patch -= 1
        while self.image.patches[self.current_patch].display is False:
            self.current_patch -= 1

        self.display_current_patch()

    else:
        self.logger.error(&#34;No Previous patches&#34;)</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.controller.controller.Controller.redo"><code class="name flex">
<span>def <span class="ident">redo</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def redo(self):

    patch = self.image.patches[self.current_patch]

    undo_patch, operation = self.undo_manager.redo()

    if undo_patch is None:
        return

    self.undo_manager.add_to_undo_stack(patch, operation)
    if len(self.undo_manager.redo_stack) == 0:
        self.main_window.toolbar_buttons[self.main_window.ID_TOOL_REDO]\
            .config(state=&#34;disabled&#34;)

    self.image.patches[self.current_patch] = undo_patch

    self.display_current_patch()</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.controller.controller.Controller.save_mask"><code class="name flex">
<span>def <span class="ident">save_mask</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Save the finished image mask</p>
<p>:returns: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_mask(self):
    &#34;&#34;&#34;
    Save the finished image mask

    :returns: None
    &#34;&#34;&#34;

    if not self.previewed:
        self.show_saved_preview()
        return

    self.mask_saved = True

    if self.last_save_dir is None:
        initial_dir = os.path.expanduser(&#39;~&#39;)
    else:
        initial_dir = self.last_save_dir

    dir_path = tkinter.filedialog.askdirectory(initialdir=initial_dir)

    self.last_save_dir = dir_path

    self.logger.debug(dir_path)

    if dir_path is None:
        return

    image_name = self.get_image_name_from_path(self.image_path)
    labels_name = self.get_landmark_name_from_path(self.image_path)

    self.mask_pathname = os.path.join(dir_path, image_name)
    self.label_pathname = os.path.join(dir_path, labels_name)

    try:
        self.logger.debug(&#34;Saving mask to {}&#34;.format(self.mask_pathname))
        self.image.export_mask(self.mask_pathname)
        # self.image.export_labels(self.label_pathname)
        tkinter.messagebox.showinfo(&#34;Image Mask Saved!&#34;, &#34;Image Mask&#34;
                                    &#34; Saved!&#34;)

    except IOError:
        self.logger.error(&#34;Could not save file!&#34;)</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.controller.controller.Controller.set_add_region_brush"><code class="name flex">
<span>def <span class="ident">set_add_region_brush</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the value of the add region brush size</p>
<p>:param value: The size
:returns: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_add_region_brush(self, value):
    &#34;&#34;&#34;
    Set the value of the add region brush size

    :param value: The size
    :returns: None
    &#34;&#34;&#34;

    self.add_region_radius = value

    self.main_window.set_brush_radius(self.add_region_radius)
    self.main_window.draw_brush()</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.controller.controller.Controller.set_flood_add_tolerance"><code class="name flex">
<span>def <span class="ident">set_flood_add_tolerance</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the current flood add tolerance</p>
<p>:param value: The value to set it to
:returns: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_flood_add_tolerance(self, value):
    &#34;&#34;&#34;
    Set the current flood add tolerance

    :param value: The value to set it to
    :returns: None
    &#34;&#34;&#34;

    if self.flood_add_position is None:
        return

    self.flood_add_tolerance = value

    patch = self.image.patches[self.current_patch]

    patch.flood_add_region(self.flood_add_position,
                           self.flood_add_tolerance)

    patch.overlay_mask()
    self.display_current_patch()</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.controller.controller.Controller.set_flood_remove_tolerance"><code class="name flex">
<span>def <span class="ident">set_flood_remove_tolerance</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the current flood remove tolerance</p>
<p>:param value: The value to set it to
:returns: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_flood_remove_tolerance(self, value):
    &#34;&#34;&#34;
    Set the current flood remove tolerance

    :param value: The value to set it to
    :returns: None
    &#34;&#34;&#34;

    if self.flood_remove_position is None:
        return

    self.flood_remove_tolerance = value

    patch = self.image.patches[self.current_patch]

    patch.flood_remove_region(self.flood_remove_position,
                              self.flood_remove_tolerance)

    patch.overlay_mask()
    self.display_current_patch()</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.controller.controller.Controller.set_remove_region_brush"><code class="name flex">
<span>def <span class="ident">set_remove_region_brush</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the value of the remove region brush size</p>
<p>:param value: The value
:returns: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_remove_region_brush(self, value):
    &#34;&#34;&#34;
    Set the value of the remove region brush size

    :param value: The value
    :returns: None
    &#34;&#34;&#34;
    self.remove_region_radius = value

    self.main_window.set_brush_radius(self.remove_region_radius)
    self.main_window.draw_brush()</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.controller.controller.Controller.set_threshold"><code class="name flex">
<span>def <span class="ident">set_threshold</span></span>(<span>self, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the value of the threshold</p>
<p>:param value: Value for the threshold
:returns: Nonw</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_threshold(self, value):
    &#34;&#34;&#34;
    Set the value of the threshold

    :param value: Value for the threshold
    :returns: Nonw
    &#34;&#34;&#34;

    patch = self.image.patches[self.current_patch]

    self.undo_manager.add_to_undo_stack(copy.deepcopy(patch),
                                        &#39;threshold_adjust&#39;)

    patch.thresh = value
    patch.apply_threshold(patch.thresh)
    patch.overlay_mask()

    self.display_current_patch()</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.controller.controller.Controller.show_saved_preview"><code class="name flex">
<span>def <span class="ident">show_saved_preview</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Display a preview of the saved mask</p>
<p>:returns: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_saved_preview(self):
    &#34;&#34;&#34;
    Display a preview of the saved mask

    :returns: None
    &#34;&#34;&#34;
    self.previewed = True
    img = self.image.image
    self.image.create_mask()
    mask = self.image.mask

    overlay = segmentation.mark_boundaries(img, mask)

    overlay = img_as_ubyte(overlay)

    rows = np.any(mask, axis=1)
    cols = np.any(mask, axis=0)
    rmin, rmax = np.where(rows)[0][[0, -1]]
    cmin, cmax = np.where(cols)[0][[0, -1]]

    overlay = overlay[rmin:rmax, cmin:cmax]

    self.main_window.create_annotation_preview(overlay)</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.controller.controller.Controller.undo"><code class="name flex">
<span>def <span class="ident">undo</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def undo(self):

    patch = self.image.patches[self.current_patch]

    redo_patch, operation = self.undo_manager.undo()

    if redo_patch is None:
        return

    self.undo_manager.add_to_redo_stack(patch, operation)
    self.main_window.toolbar_buttons[self.main_window.ID_TOOL_REDO]\
        .config(state=&#34;normal&#34;)

    self.image.patches[self.current_patch] = redo_patch

    self.display_current_patch()</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.controller.controller.Controller.update_progress_bar"><code class="name flex">
<span>def <span class="ident">update_progress_bar</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the progress bar popup</p>
<p>:returns: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_progress_bar(self):
    &#34;&#34;&#34;
    Update the progress bar popup

    :returns: None
    &#34;&#34;&#34;

    self.main_window.prog_popup.update()
    self.main_window.load_progress += self.main_window.progress_step
    self.main_window.load_prog_var.set(self.main_window.load_progress)

    if self.main_window.load_progress &gt;= Image.NUM_PATCHES ** 2:
        self.main_window.prog_popup.destroy()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="friendly_ground_truth.controller.controller.Mode"><code class="flex name class">
<span>class <span class="ident">Mode</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Class representing the possible modes for editing</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>THREHSOLD</code></strong></dt>
<dd>&nbsp;</dd>
<dt><strong><code>ETC</code></strong></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Mode(Enum):
    &#34;&#34;&#34;
    Class representing the possible modes for editing

    Attributes:
        THREHSOLD
        ETC
    &#34;&#34;&#34;
    THRESHOLD = 1
    ADD_REGION = 2
    REMOVE_REGION = 3
    NO_ROOT = 4
    FLOOD_ADD = 6
    FLOOD_REMOVE = 7
    ADD_TIP = 8
    ADD_BRANCH = 9
    ADD_CROSSING = 10
    REMOVE_LANDMARK = 11</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="friendly_ground_truth.controller.controller.Mode.ADD_BRANCH"><code class="name">var <span class="ident">ADD_BRANCH</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="friendly_ground_truth.controller.controller.Mode.ADD_CROSSING"><code class="name">var <span class="ident">ADD_CROSSING</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="friendly_ground_truth.controller.controller.Mode.ADD_REGION"><code class="name">var <span class="ident">ADD_REGION</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="friendly_ground_truth.controller.controller.Mode.ADD_TIP"><code class="name">var <span class="ident">ADD_TIP</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="friendly_ground_truth.controller.controller.Mode.FLOOD_ADD"><code class="name">var <span class="ident">FLOOD_ADD</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="friendly_ground_truth.controller.controller.Mode.FLOOD_REMOVE"><code class="name">var <span class="ident">FLOOD_REMOVE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="friendly_ground_truth.controller.controller.Mode.NO_ROOT"><code class="name">var <span class="ident">NO_ROOT</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="friendly_ground_truth.controller.controller.Mode.REMOVE_LANDMARK"><code class="name">var <span class="ident">REMOVE_LANDMARK</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="friendly_ground_truth.controller.controller.Mode.REMOVE_REGION"><code class="name">var <span class="ident">REMOVE_REGION</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="friendly_ground_truth.controller.controller.Mode.THRESHOLD"><code class="name">var <span class="ident">THRESHOLD</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="friendly_ground_truth.controller.controller.SecondaryMode"><code class="flex name class">
<span>class <span class="ident">SecondaryMode</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Class representing secondary adjustment modes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SecondaryMode(Enum):
    &#34;&#34;&#34;
    Class representing secondary adjustment modes
    &#34;&#34;&#34;
    ZOOM = 1
    ADJUST_TOOL = 2</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="friendly_ground_truth.controller.controller.SecondaryMode.ADJUST_TOOL"><code class="name">var <span class="ident">ADJUST_TOOL</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="friendly_ground_truth.controller.controller.SecondaryMode.ZOOM"><code class="name">var <span class="ident">ZOOM</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="friendly_ground_truth.controller.controller.UndoManager"><code class="flex name class">
<span>class <span class="ident">UndoManager</span></span>
</code></dt>
<dd>
<div class="desc"><p>Manages Undo Stuff</p>
<p>Initialize the Undo Manager</p>
<p>:returns: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UndoManager():
    &#34;&#34;&#34;
    Manages Undo Stuff
    &#34;&#34;&#34;

    MAX_SIZE = 20

    def __init__(self):
        &#34;&#34;&#34;
        Initialize the Undo Manager

        :returns: None
        &#34;&#34;&#34;

        self.undo_stack = []
        self.redo_stack = []

    def add_to_undo_stack(self, patch, operation):
        &#34;&#34;&#34;
        Add the given operation to the undo stack

        :returns: None
        &#34;&#34;&#34;

        if &#34;threshold_adjust&#34; == operation and len(self.undo_stack) &gt; 0:
            if self.undo_stack[-1][1] == operation:
                return
        elif &#34;adjust&#34; in operation and len(self.undo_stack) &gt; 0:
            if self.undo_stack[-1][1] == operation:
                self.undo_stack.pop()

        self.undo_stack.append((patch, operation))

        if len(self.undo_stack) &gt; self.MAX_SIZE:
            self.undo_stack.pop(0)

    def undo(self):
        &#34;&#34;&#34;
        Undo the last operation added to the stack

        :returns: The function and its parameters
        &#34;&#34;&#34;
        try:
            patch, operation = self.undo_stack.pop()
            return patch, operation

        except IndexError:
            return None, None

    def add_to_redo_stack(self, patch, operation):
        &#34;&#34;&#34;
        Add the given operation to the redo stack

        :returns: None
        &#34;&#34;&#34;

        self.redo_stack.append((patch, operation))

        if len(self.redo_stack) &gt; self.MAX_SIZE:
            self.redo_stack.pop(0)

    def redo(self):
        &#34;&#34;&#34;
        Redo the last undone operation

        :returns: The function and its parameters
        &#34;&#34;&#34;

        try:
            patch, operation = self.redo_stack.pop()
            return patch, operation
        except IndexError:
            return None, None

    def clear_undos(self):

        self.undo_stack = []
        self.redo_stack = []</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="friendly_ground_truth.controller.controller.UndoManager.MAX_SIZE"><code class="name">var <span class="ident">MAX_SIZE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="friendly_ground_truth.controller.controller.UndoManager.add_to_redo_stack"><code class="name flex">
<span>def <span class="ident">add_to_redo_stack</span></span>(<span>self, patch, operation)</span>
</code></dt>
<dd>
<div class="desc"><p>Add the given operation to the redo stack</p>
<p>:returns: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_to_redo_stack(self, patch, operation):
    &#34;&#34;&#34;
    Add the given operation to the redo stack

    :returns: None
    &#34;&#34;&#34;

    self.redo_stack.append((patch, operation))

    if len(self.redo_stack) &gt; self.MAX_SIZE:
        self.redo_stack.pop(0)</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.controller.controller.UndoManager.add_to_undo_stack"><code class="name flex">
<span>def <span class="ident">add_to_undo_stack</span></span>(<span>self, patch, operation)</span>
</code></dt>
<dd>
<div class="desc"><p>Add the given operation to the undo stack</p>
<p>:returns: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_to_undo_stack(self, patch, operation):
    &#34;&#34;&#34;
    Add the given operation to the undo stack

    :returns: None
    &#34;&#34;&#34;

    if &#34;threshold_adjust&#34; == operation and len(self.undo_stack) &gt; 0:
        if self.undo_stack[-1][1] == operation:
            return
    elif &#34;adjust&#34; in operation and len(self.undo_stack) &gt; 0:
        if self.undo_stack[-1][1] == operation:
            self.undo_stack.pop()

    self.undo_stack.append((patch, operation))

    if len(self.undo_stack) &gt; self.MAX_SIZE:
        self.undo_stack.pop(0)</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.controller.controller.UndoManager.clear_undos"><code class="name flex">
<span>def <span class="ident">clear_undos</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_undos(self):

    self.undo_stack = []
    self.redo_stack = []</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.controller.controller.UndoManager.redo"><code class="name flex">
<span>def <span class="ident">redo</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Redo the last undone operation</p>
<p>:returns: The function and its parameters</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def redo(self):
    &#34;&#34;&#34;
    Redo the last undone operation

    :returns: The function and its parameters
    &#34;&#34;&#34;

    try:
        patch, operation = self.redo_stack.pop()
        return patch, operation
    except IndexError:
        return None, None</code></pre>
</details>
</dd>
<dt id="friendly_ground_truth.controller.controller.UndoManager.undo"><code class="name flex">
<span>def <span class="ident">undo</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Undo the last operation added to the stack</p>
<p>:returns: The function and its parameters</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def undo(self):
    &#34;&#34;&#34;
    Undo the last operation added to the stack

    :returns: The function and its parameters
    &#34;&#34;&#34;
    try:
        patch, operation = self.undo_stack.pop()
        return patch, operation

    except IndexError:
        return None, None</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="friendly_ground_truth.controller" href="index.html">friendly_ground_truth.controller</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="friendly_ground_truth.controller.controller.Controller" href="#friendly_ground_truth.controller.controller.Controller">Controller</a></code></h4>
<ul class="">
<li><code><a title="friendly_ground_truth.controller.controller.Controller.CONTEXT_TRANSPARENCY" href="#friendly_ground_truth.controller.controller.Controller.CONTEXT_TRANSPARENCY">CONTEXT_TRANSPARENCY</a></code></li>
<li><code><a title="friendly_ground_truth.controller.controller.Controller.ZOOM_SCALE" href="#friendly_ground_truth.controller.controller.Controller.ZOOM_SCALE">ZOOM_SCALE</a></code></li>
<li><code><a title="friendly_ground_truth.controller.controller.Controller.adjust_add_region_brush" href="#friendly_ground_truth.controller.controller.Controller.adjust_add_region_brush">adjust_add_region_brush</a></code></li>
<li><code><a title="friendly_ground_truth.controller.controller.Controller.adjust_remove_landmark_brush" href="#friendly_ground_truth.controller.controller.Controller.adjust_remove_landmark_brush">adjust_remove_landmark_brush</a></code></li>
<li><code><a title="friendly_ground_truth.controller.controller.Controller.adjust_remove_region_brush" href="#friendly_ground_truth.controller.controller.Controller.adjust_remove_region_brush">adjust_remove_region_brush</a></code></li>
<li><code><a title="friendly_ground_truth.controller.controller.Controller.adjust_threshold" href="#friendly_ground_truth.controller.controller.Controller.adjust_threshold">adjust_threshold</a></code></li>
<li><code><a title="friendly_ground_truth.controller.controller.Controller.change_mode" href="#friendly_ground_truth.controller.controller.Controller.change_mode">change_mode</a></code></li>
<li><code><a title="friendly_ground_truth.controller.controller.Controller.change_secondary_mode" href="#friendly_ground_truth.controller.controller.Controller.change_secondary_mode">change_secondary_mode</a></code></li>
<li><code><a title="friendly_ground_truth.controller.controller.Controller.convert_click_to_image_position" href="#friendly_ground_truth.controller.controller.Controller.convert_click_to_image_position">convert_click_to_image_position</a></code></li>
<li><code><a title="friendly_ground_truth.controller.controller.Controller.display_current_patch" href="#friendly_ground_truth.controller.controller.Controller.display_current_patch">display_current_patch</a></code></li>
<li><code><a title="friendly_ground_truth.controller.controller.Controller.get_context_patches" href="#friendly_ground_truth.controller.controller.Controller.get_context_patches">get_context_patches</a></code></li>
<li><code><a title="friendly_ground_truth.controller.controller.Controller.get_image_name_from_path" href="#friendly_ground_truth.controller.controller.Controller.get_image_name_from_path">get_image_name_from_path</a></code></li>
<li><code><a title="friendly_ground_truth.controller.controller.Controller.get_landmark_name_from_path" href="#friendly_ground_truth.controller.controller.Controller.get_landmark_name_from_path">get_landmark_name_from_path</a></code></li>
<li><code><a title="friendly_ground_truth.controller.controller.Controller.handle_flood_add_tolerance" href="#friendly_ground_truth.controller.controller.Controller.handle_flood_add_tolerance">handle_flood_add_tolerance</a></code></li>
<li><code><a title="friendly_ground_truth.controller.controller.Controller.handle_flood_remove_tolerance" href="#friendly_ground_truth.controller.controller.Controller.handle_flood_remove_tolerance">handle_flood_remove_tolerance</a></code></li>
<li><code><a title="friendly_ground_truth.controller.controller.Controller.handle_left_click" href="#friendly_ground_truth.controller.controller.Controller.handle_left_click">handle_left_click</a></code></li>
<li><code><a title="friendly_ground_truth.controller.controller.Controller.handle_left_release" href="#friendly_ground_truth.controller.controller.Controller.handle_left_release">handle_left_release</a></code></li>
<li><code><a title="friendly_ground_truth.controller.controller.Controller.handle_motion" href="#friendly_ground_truth.controller.controller.Controller.handle_motion">handle_motion</a></code></li>
<li><code><a title="friendly_ground_truth.controller.controller.Controller.handle_mouse_wheel" href="#friendly_ground_truth.controller.controller.Controller.handle_mouse_wheel">handle_mouse_wheel</a></code></li>
<li><code><a title="friendly_ground_truth.controller.controller.Controller.handle_mouse_wheel_motion" href="#friendly_ground_truth.controller.controller.Controller.handle_mouse_wheel_motion">handle_mouse_wheel_motion</a></code></li>
<li><code><a title="friendly_ground_truth.controller.controller.Controller.handle_right_click" href="#friendly_ground_truth.controller.controller.Controller.handle_right_click">handle_right_click</a></code></li>
<li><code><a title="friendly_ground_truth.controller.controller.Controller.handle_zoom" href="#friendly_ground_truth.controller.controller.Controller.handle_zoom">handle_zoom</a></code></li>
<li><code><a title="friendly_ground_truth.controller.controller.Controller.load_new_image" href="#friendly_ground_truth.controller.controller.Controller.load_new_image">load_new_image</a></code></li>
<li><code><a title="friendly_ground_truth.controller.controller.Controller.next_patch" href="#friendly_ground_truth.controller.controller.Controller.next_patch">next_patch</a></code></li>
<li><code><a title="friendly_ground_truth.controller.controller.Controller.no_root_activate" href="#friendly_ground_truth.controller.controller.Controller.no_root_activate">no_root_activate</a></code></li>
<li><code><a title="friendly_ground_truth.controller.controller.Controller.prev_patch" href="#friendly_ground_truth.controller.controller.Controller.prev_patch">prev_patch</a></code></li>
<li><code><a title="friendly_ground_truth.controller.controller.Controller.redo" href="#friendly_ground_truth.controller.controller.Controller.redo">redo</a></code></li>
<li><code><a title="friendly_ground_truth.controller.controller.Controller.save_mask" href="#friendly_ground_truth.controller.controller.Controller.save_mask">save_mask</a></code></li>
<li><code><a title="friendly_ground_truth.controller.controller.Controller.set_add_region_brush" href="#friendly_ground_truth.controller.controller.Controller.set_add_region_brush">set_add_region_brush</a></code></li>
<li><code><a title="friendly_ground_truth.controller.controller.Controller.set_flood_add_tolerance" href="#friendly_ground_truth.controller.controller.Controller.set_flood_add_tolerance">set_flood_add_tolerance</a></code></li>
<li><code><a title="friendly_ground_truth.controller.controller.Controller.set_flood_remove_tolerance" href="#friendly_ground_truth.controller.controller.Controller.set_flood_remove_tolerance">set_flood_remove_tolerance</a></code></li>
<li><code><a title="friendly_ground_truth.controller.controller.Controller.set_remove_region_brush" href="#friendly_ground_truth.controller.controller.Controller.set_remove_region_brush">set_remove_region_brush</a></code></li>
<li><code><a title="friendly_ground_truth.controller.controller.Controller.set_threshold" href="#friendly_ground_truth.controller.controller.Controller.set_threshold">set_threshold</a></code></li>
<li><code><a title="friendly_ground_truth.controller.controller.Controller.show_saved_preview" href="#friendly_ground_truth.controller.controller.Controller.show_saved_preview">show_saved_preview</a></code></li>
<li><code><a title="friendly_ground_truth.controller.controller.Controller.undo" href="#friendly_ground_truth.controller.controller.Controller.undo">undo</a></code></li>
<li><code><a title="friendly_ground_truth.controller.controller.Controller.update_progress_bar" href="#friendly_ground_truth.controller.controller.Controller.update_progress_bar">update_progress_bar</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="friendly_ground_truth.controller.controller.Mode" href="#friendly_ground_truth.controller.controller.Mode">Mode</a></code></h4>
<ul class="two-column">
<li><code><a title="friendly_ground_truth.controller.controller.Mode.ADD_BRANCH" href="#friendly_ground_truth.controller.controller.Mode.ADD_BRANCH">ADD_BRANCH</a></code></li>
<li><code><a title="friendly_ground_truth.controller.controller.Mode.ADD_CROSSING" href="#friendly_ground_truth.controller.controller.Mode.ADD_CROSSING">ADD_CROSSING</a></code></li>
<li><code><a title="friendly_ground_truth.controller.controller.Mode.ADD_REGION" href="#friendly_ground_truth.controller.controller.Mode.ADD_REGION">ADD_REGION</a></code></li>
<li><code><a title="friendly_ground_truth.controller.controller.Mode.ADD_TIP" href="#friendly_ground_truth.controller.controller.Mode.ADD_TIP">ADD_TIP</a></code></li>
<li><code><a title="friendly_ground_truth.controller.controller.Mode.FLOOD_ADD" href="#friendly_ground_truth.controller.controller.Mode.FLOOD_ADD">FLOOD_ADD</a></code></li>
<li><code><a title="friendly_ground_truth.controller.controller.Mode.FLOOD_REMOVE" href="#friendly_ground_truth.controller.controller.Mode.FLOOD_REMOVE">FLOOD_REMOVE</a></code></li>
<li><code><a title="friendly_ground_truth.controller.controller.Mode.NO_ROOT" href="#friendly_ground_truth.controller.controller.Mode.NO_ROOT">NO_ROOT</a></code></li>
<li><code><a title="friendly_ground_truth.controller.controller.Mode.REMOVE_LANDMARK" href="#friendly_ground_truth.controller.controller.Mode.REMOVE_LANDMARK">REMOVE_LANDMARK</a></code></li>
<li><code><a title="friendly_ground_truth.controller.controller.Mode.REMOVE_REGION" href="#friendly_ground_truth.controller.controller.Mode.REMOVE_REGION">REMOVE_REGION</a></code></li>
<li><code><a title="friendly_ground_truth.controller.controller.Mode.THRESHOLD" href="#friendly_ground_truth.controller.controller.Mode.THRESHOLD">THRESHOLD</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="friendly_ground_truth.controller.controller.SecondaryMode" href="#friendly_ground_truth.controller.controller.SecondaryMode">SecondaryMode</a></code></h4>
<ul class="">
<li><code><a title="friendly_ground_truth.controller.controller.SecondaryMode.ADJUST_TOOL" href="#friendly_ground_truth.controller.controller.SecondaryMode.ADJUST_TOOL">ADJUST_TOOL</a></code></li>
<li><code><a title="friendly_ground_truth.controller.controller.SecondaryMode.ZOOM" href="#friendly_ground_truth.controller.controller.SecondaryMode.ZOOM">ZOOM</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="friendly_ground_truth.controller.controller.UndoManager" href="#friendly_ground_truth.controller.controller.UndoManager">UndoManager</a></code></h4>
<ul class="two-column">
<li><code><a title="friendly_ground_truth.controller.controller.UndoManager.MAX_SIZE" href="#friendly_ground_truth.controller.controller.UndoManager.MAX_SIZE">MAX_SIZE</a></code></li>
<li><code><a title="friendly_ground_truth.controller.controller.UndoManager.add_to_redo_stack" href="#friendly_ground_truth.controller.controller.UndoManager.add_to_redo_stack">add_to_redo_stack</a></code></li>
<li><code><a title="friendly_ground_truth.controller.controller.UndoManager.add_to_undo_stack" href="#friendly_ground_truth.controller.controller.UndoManager.add_to_undo_stack">add_to_undo_stack</a></code></li>
<li><code><a title="friendly_ground_truth.controller.controller.UndoManager.clear_undos" href="#friendly_ground_truth.controller.controller.UndoManager.clear_undos">clear_undos</a></code></li>
<li><code><a title="friendly_ground_truth.controller.controller.UndoManager.redo" href="#friendly_ground_truth.controller.controller.UndoManager.redo">redo</a></code></li>
<li><code><a title="friendly_ground_truth.controller.controller.UndoManager.undo" href="#friendly_ground_truth.controller.controller.UndoManager.undo">undo</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>